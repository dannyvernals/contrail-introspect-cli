#
# Autogenerated by Sandesh Compiler (1.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#

from pysandesh.Thrift import TType, TMessageType, TException

from pysandesh.transport import TTransport
from pysandesh.protocol import TBinaryProtocol, TProtocol
try:
  from pysandesh.protocol import fastbinary
except:
  fastbinary = None

import cStringIO
import uuid
import netaddr
from sys import getsizeof
from itertools import chain
import bottle
from pysandesh import sandesh_base
from pysandesh.sandesh_http import SandeshHttp
from pysandesh.sandesh_uve import SandeshUVETypeMaps
from pysandesh.util import UTCTimestampUsec, UTCTimestampUsecToString
from pysandesh import util
from pysandesh.gen_py.sandesh.constants import *



class SandeshTraceBufInfo(object):
  """
  Attributes:
   - trace_buf_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'trace_buf_name', None, None, ), # 1
  )

  def __init__(self, trace_buf_name=None,):
    self.trace_buf_name = trace_buf_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.trace_buf_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.trace_buf_name is not None:
      annotations = {}
      annotations['link'] = 'SandeshTraceRequest'
      if oprot.writeFieldBegin('trace_buf_name', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.trace_buf_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.trace_buf_name is not None:
      log_str.write('trace_buf_name = ')
      log_str.write(self.trace_buf_name)
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.trace_buf_name is not None:
      size += getsizeof(self.trace_buf_name)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceBufStatusInfo(object):
  """
  Attributes:
   - trace_buf_name
   - enable_disable
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'trace_buf_name', None, None, ), # 1
    (2, TType.STRING, 'enable_disable', None, None, ), # 2
  )

  def __init__(self, trace_buf_name=None, enable_disable=None,):
    self.trace_buf_name = trace_buf_name
    self.enable_disable = enable_disable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.trace_buf_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.enable_disable) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.trace_buf_name is not None:
      annotations = {}
      annotations['link'] = 'SandeshTraceRequest'
      if oprot.writeFieldBegin('trace_buf_name', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.trace_buf_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.enable_disable is not None:
      annotations = {}
      if oprot.writeFieldBegin('enable_disable', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.enable_disable) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.trace_buf_name is not None:
      log_str.write('trace_buf_name = ')
      log_str.write(self.trace_buf_name)
      log_str.write('  ')
    if self.enable_disable is not None:
      log_str.write('enable_disable = ')
      log_str.write(self.enable_disable)
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.trace_buf_name is not None:
      size += getsizeof(self.trace_buf_name)
    if self.enable_disable is not None:
      size += getsizeof(self.enable_disable)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceRequest(sandesh_base.SandeshRequest):

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'buf_name', None, None, ), # 1
    (2, TType.I32, 'count', None, None, ), # 2
  )

  def __init__(self, buf_name=None, count=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self.buf_name = buf_name
    self.count = count
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2976035096
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshTraceRequest()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshTraceRequest" not implemented')
    if bottle.request.query.x:
      sandesh_req.buf_name = str(bottle.request.query.x)
    if bottle.request.query.buf_name:
      sandesh_req.buf_name = str(bottle.request.query.buf_name)
    if bottle.request.query.count:
      try:
        sandesh_req.count = int(bottle.request.query.count)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshTraceRequest" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshTraceRequest"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.buf_name is not None:
      log_str.write('buf_name = ')
      log_str.write(self.buf_name)
      log_str.write('  ')
    if self.count is not None:
      log_str.write('count = ')
      log_str.write(str(self.count))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.buf_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          (length, self.count) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.buf_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('buf_name', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.buf_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.count is not None:
      annotations = {}
      if oprot.writeFieldBegin('count', TType.I32, 2, annotations) < 0: return -1
      if oprot.writeI32(self.count) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.buf_name != other.buf_name:
      return False
    if self.count != other.count:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.buf_name is not None:
      size += getsizeof(self.buf_name)
    if self.count is not None:
      size += getsizeof(self.count)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceBufferListRequest(sandesh_base.SandeshRequest):

  thrift_spec = (
  )

  def __init__(self, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2471203225
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshTraceBufferListRequest()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshTraceBufferListRequest" not implemented')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshTraceBufferListRequest" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshTraceBufferListRequest"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    return True

  def __sizeof__(self):
    size = 0
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceBufferListResponse(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.LIST, 'trace_buffer_list', (TType.STRUCT,(SandeshTraceBufInfo, SandeshTraceBufInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, trace_buffer_list=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.trace_buffer_list = trace_buffer_list
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 231130853
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.trace_buffer_list is not None:
      log_str.write('trace_buffer_list = ')
      log_str.write('[ ')
      for iter0 in self.trace_buffer_list:
        log_str.write('<<  ')
        log_str.write(iter0.log())
        log_str.write('>>')
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.trace_buffer_list = []
          (length, _etype4, _size1) = iprot.readListBegin()
          read_cnt += length
          for _i5 in xrange(_size1):
            _elem6 = SandeshTraceBufInfo()
            read_cnt += _elem6.read(iprot)
            self.trace_buffer_list.append(_elem6)
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.trace_buffer_list is not None:
      annotations = {}
      if oprot.writeFieldBegin('trace_buffer_list', TType.LIST, 1, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRUCT, len(self.trace_buffer_list)) < 0: return -1
      for iter7 in self.trace_buffer_list:
        if iter7.write(oprot) < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.trace_buffer_list != other.trace_buffer_list:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.trace_buffer_list is not None:
      size += getsizeof(self.trace_buffer_list)
      size += sum(map(getsizeof, self.trace_buffer_list))
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceText(sandesh_base.SandeshTrace):

  thrift_spec = None

  def __init__(self, tracemsg=None, file=None, line=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshTrace.__init__(self, type=SandeshType.TRACE)
    self.tracemsg = tracemsg
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2183673535
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.tracemsg is not None:
      log_str.write(self.tracemsg)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.tracemsg) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.tracemsg is not None:
      annotations = {}
      if oprot.writeFieldBegin('tracemsg', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.tracemsg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.tracemsg != other.tracemsg:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.tracemsg is not None:
      size += getsizeof(self.tracemsg)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceTextResponse(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.LIST, 'traces', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, traces=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.traces = traces
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 289982834
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.traces is not None:
      log_str.write('traces = ')
      log_str.write('[ ')
      for iter8 in self.traces:
        log_str.write(iter8)
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.traces = []
          (length, _etype12, _size9) = iprot.readListBegin()
          read_cnt += length
          for _i13 in xrange(_size9):
            read_cnt += iprot.readContainerElementBegin()
            (length, _elem14) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            self.traces.append(_elem14)
            read_cnt += iprot.readContainerElementEnd()
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.traces is not None:
      annotations = {}
      if oprot.writeFieldBegin('traces', TType.LIST, 1, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRING, len(self.traces)) < 0: return -1
      for iter15 in self.traces:
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(iter15) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.traces != other.traces:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.traces is not None:
      size += getsizeof(self.traces)
      size += sum(map(getsizeof, self.traces))
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceEnableDisableReq(sandesh_base.SandeshRequest):

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'enable', None, None, ), # 1
  )

  def __init__(self, enable=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self.enable = enable
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 1380320703
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshTraceEnableDisableReq()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshTraceEnableDisableReq" not implemented')
    if bottle.request.query.x:
      try:
        sandesh_req.enable = int(bottle.request.query.x)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.enable:
      try:
        sandesh_req.enable = int(bottle.request.query.enable)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshTraceEnableDisableReq" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshTraceEnableDisableReq"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.enable is not None:
      log_str.write('enable = ')
      if self.enable:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          (length, self.enable) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.enable is not None:
      annotations = {}
      if oprot.writeFieldBegin('enable', TType.BOOL, 1, annotations) < 0: return -1
      if oprot.writeBool(self.enable) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.enable != other.enable:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.enable is not None:
      size += getsizeof(self.enable)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceEnableDisableRes(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.STRING, 'enable_disable_status', None, None, ), # 1
  )

  def __init__(self, enable_disable_status=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.enable_disable_status = enable_disable_status
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 1213733715
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.enable_disable_status is not None:
      log_str.write('enable_disable_status = ')
      log_str.write(self.enable_disable_status)
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.enable_disable_status) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.enable_disable_status is not None:
      annotations = {}
      if oprot.writeFieldBegin('enable_disable_status', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.enable_disable_status) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.enable_disable_status != other.enable_disable_status:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.enable_disable_status is not None:
      size += getsizeof(self.enable_disable_status)
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceBufStatusReq(sandesh_base.SandeshRequest):

  thrift_spec = (
  )

  def __init__(self, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2471203225
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshTraceBufStatusReq()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshTraceBufStatusReq" not implemented')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshTraceBufStatusReq" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshTraceBufStatusReq"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    return True

  def __sizeof__(self):
    size = 0
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceBufStatusRes(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.LIST, 'trace_buf_status_list', (TType.STRUCT,(SandeshTraceBufStatusInfo, SandeshTraceBufStatusInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, trace_buf_status_list=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.trace_buf_status_list = trace_buf_status_list
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 713640610
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.trace_buf_status_list is not None:
      log_str.write('trace_buf_status_list = ')
      log_str.write('[ ')
      for iter16 in self.trace_buf_status_list:
        log_str.write('<<  ')
        log_str.write(iter16.log())
        log_str.write('>>')
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.trace_buf_status_list = []
          (length, _etype20, _size17) = iprot.readListBegin()
          read_cnt += length
          for _i21 in xrange(_size17):
            _elem22 = SandeshTraceBufStatusInfo()
            read_cnt += _elem22.read(iprot)
            self.trace_buf_status_list.append(_elem22)
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.trace_buf_status_list is not None:
      annotations = {}
      if oprot.writeFieldBegin('trace_buf_status_list', TType.LIST, 1, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRUCT, len(self.trace_buf_status_list)) < 0: return -1
      for iter23 in self.trace_buf_status_list:
        if iter23.write(oprot) < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.trace_buf_status_list != other.trace_buf_status_list:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.trace_buf_status_list is not None:
      size += getsizeof(self.trace_buf_status_list)
      size += sum(map(getsizeof, self.trace_buf_status_list))
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceBufferEnableDisableReq(sandesh_base.SandeshRequest):

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'trace_buf_name', None, None, ), # 1
    (2, TType.BOOL, 'enable', None, None, ), # 2
  )

  def __init__(self, trace_buf_name=None, enable=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self.trace_buf_name = trace_buf_name
    self.enable = enable
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 3428872315
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshTraceBufferEnableDisableReq()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshTraceBufferEnableDisableReq" not implemented')
    if bottle.request.query.x:
      sandesh_req.trace_buf_name = str(bottle.request.query.x)
    if bottle.request.query.trace_buf_name:
      sandesh_req.trace_buf_name = str(bottle.request.query.trace_buf_name)
    if bottle.request.query.enable:
      try:
        sandesh_req.enable = int(bottle.request.query.enable)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshTraceBufferEnableDisableReq" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshTraceBufferEnableDisableReq"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.trace_buf_name is not None:
      log_str.write('trace_buf_name = ')
      log_str.write(self.trace_buf_name)
      log_str.write('  ')
    if self.enable is not None:
      log_str.write('enable = ')
      if self.enable:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.trace_buf_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          (length, self.enable) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.trace_buf_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('trace_buf_name', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.trace_buf_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.enable is not None:
      annotations = {}
      if oprot.writeFieldBegin('enable', TType.BOOL, 2, annotations) < 0: return -1
      if oprot.writeBool(self.enable) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.trace_buf_name != other.trace_buf_name:
      return False
    if self.enable != other.enable:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.trace_buf_name is not None:
      size += getsizeof(self.trace_buf_name)
    if self.enable is not None:
      size += getsizeof(self.enable)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshTraceBufferEnableDisableRes(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.STRING, 'enable_disable_status', None, None, ), # 1
  )

  def __init__(self, enable_disable_status=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.enable_disable_status = enable_disable_status
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 1213733715
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.enable_disable_status is not None:
      log_str.write('enable_disable_status = ')
      log_str.write(self.enable_disable_status)
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.enable_disable_status) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.enable_disable_status is not None:
      annotations = {}
      if oprot.writeFieldBegin('enable_disable_status', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.enable_disable_status) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.enable_disable_status != other.enable_disable_status:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.enable_disable_status is not None:
      size += getsizeof(self.enable_disable_status)
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


_SANDESH_REQUEST_LIST = [
SandeshTraceRequest,
SandeshTraceBufferListRequest,
SandeshTraceEnableDisableReq,
SandeshTraceBufStatusReq,
SandeshTraceBufferEnableDisableReq,
]


_SANDESH_UVE_LIST = [
]


_SANDESH_ALARM_LIST = [
]
