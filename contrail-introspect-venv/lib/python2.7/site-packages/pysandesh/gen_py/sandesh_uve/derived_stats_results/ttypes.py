#
# Autogenerated by Sandesh Compiler (1.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#

from pysandesh.Thrift import TType, TMessageType, TException

from pysandesh.transport import TTransport
from pysandesh.protocol import TBinaryProtocol, TProtocol
try:
  from pysandesh.protocol import fastbinary
except:
  fastbinary = None

import cStringIO
import uuid
import netaddr
from sys import getsizeof
from itertools import chain
import bottle
from pysandesh import sandesh_base
from pysandesh.sandesh_http import SandeshHttp
from pysandesh.sandesh_uve import SandeshUVETypeMaps
from pysandesh.util import UTCTimestampUsec, UTCTimestampUsecToString
from pysandesh import util
from pysandesh.gen_py.sandesh.constants import *



class NullResult(object):
  """
  Derived Statistics Implementation

  Attributes:
   - samples
   - value
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    (3, TType.U64, 'samples', None, None, ), # 3
    None, # 4
    (5, TType.I32, 'value', None, None, ), # 5
  )

  def __init__(self, samples=None, value=None,):
    self.samples = samples
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 3:
        if ftype == TType.U64:
          (length, self.samples) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          (length, self.value) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.samples is not None:
      annotations = {}
      if oprot.writeFieldBegin('samples', TType.U64, 3, annotations) < 0: return -1
      if oprot.writeU64(self.samples) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.value is not None:
      annotations = {}
      if oprot.writeFieldBegin('value', TType.I32, 5, annotations) < 0: return -1
      if oprot.writeI32(self.value) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.samples is not None:
      log_str.write('samples = ')
      log_str.write(str(self.samples))
      log_str.write('  ')
    if self.value is not None:
      log_str.write('value = ')
      log_str.write(str(self.value))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.samples is not None:
      size += getsizeof(self.samples)
    if self.value is not None:
      size += getsizeof(self.value)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EWMResult(object):
  """
  Attributes:
   - samples
   - error
   - mean
   - stddev
   - sigma
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    (3, TType.U64, 'samples', None, None, ), # 3
    (4, TType.STRING, 'error', None, None, ), # 4
    None, # 5
    (6, TType.DOUBLE, 'mean', None, None, ), # 6
    (7, TType.DOUBLE, 'stddev', None, None, ), # 7
    (8, TType.DOUBLE, 'sigma', None, None, ), # 8
  )

  def __init__(self, samples=None, error=None, mean=None, stddev=None, sigma=None,):
    self.samples = samples
    self.error = error
    self.mean = mean
    self.stddev = stddev
    self.sigma = sigma

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 3:
        if ftype == TType.U64:
          (length, self.samples) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.error) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          (length, self.mean) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          (length, self.stddev) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          (length, self.sigma) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.samples is not None:
      annotations = {}
      if oprot.writeFieldBegin('samples', TType.U64, 3, annotations) < 0: return -1
      if oprot.writeU64(self.samples) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.error is not None:
      annotations = {}
      if oprot.writeFieldBegin('error', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.error) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.mean is not None:
      annotations = {}
      if oprot.writeFieldBegin('mean', TType.DOUBLE, 6, annotations) < 0: return -1
      if oprot.writeDouble(self.mean) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.stddev is not None:
      annotations = {}
      if oprot.writeFieldBegin('stddev', TType.DOUBLE, 7, annotations) < 0: return -1
      if oprot.writeDouble(self.stddev) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.sigma is not None:
      annotations = {}
      if oprot.writeFieldBegin('sigma', TType.DOUBLE, 8, annotations) < 0: return -1
      if oprot.writeDouble(self.sigma) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.samples is not None:
      log_str.write('samples = ')
      log_str.write(str(self.samples))
      log_str.write('  ')
    if self.error is not None:
      log_str.write('error = ')
      log_str.write(self.error)
      log_str.write('  ')
    if self.mean is not None:
      log_str.write('mean = ')
      log_str.write(str(self.mean))
      log_str.write('  ')
    if self.stddev is not None:
      log_str.write('stddev = ')
      log_str.write(str(self.stddev))
      log_str.write('  ')
    if self.sigma is not None:
      log_str.write('sigma = ')
      log_str.write(str(self.sigma))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.samples is not None:
      size += getsizeof(self.samples)
    if self.error is not None:
      size += getsizeof(self.error)
    if self.mean is not None:
      size += getsizeof(self.mean)
    if self.stddev is not None:
      size += getsizeof(self.stddev)
    if self.sigma is not None:
      size += getsizeof(self.sigma)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AnomalyResult(object):
  """
  Attributes:
   - samples
   - algo
   - config
   - error
   - state
   - sigma
   - metric
  """

  thrift_spec = (
    None, # 0
    (1, TType.U64, 'samples', None, None, ), # 1
    (2, TType.STRING, 'algo', None, None, ), # 2
    (3, TType.STRING, 'config', None, None, ), # 3
    (4, TType.STRING, 'error', None, None, ), # 4
    (5, TType.MAP, 'state', (TType.STRING,None,TType.STRING,None), None, ), # 5
    (6, TType.DOUBLE, 'sigma', None, None, ), # 6
    (7, TType.U64, 'metric', None, None, ), # 7
  )

  def __init__(self, samples=None, algo=None, config=None, error=None, state=None, sigma=None, metric=None,):
    self.samples = samples
    self.algo = algo
    self.config = config
    self.error = error
    self.state = state
    self.sigma = sigma
    self.metric = metric

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U64:
          (length, self.samples) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.algo) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.config) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.error) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.state = {}
          (length, _ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          read_cnt += length
          for _i4 in xrange(_size0):
            read_cnt += iprot.readContainerElementBegin()
            (length, _key5) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            read_cnt += iprot.readContainerElementBegin()
            (length, _val6) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            self.state[_key5] = _val6
          read_cnt += iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          (length, self.sigma) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.U64:
          (length, self.metric) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.samples is not None:
      annotations = {}
      if oprot.writeFieldBegin('samples', TType.U64, 1, annotations) < 0: return -1
      if oprot.writeU64(self.samples) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.algo is not None:
      annotations = {}
      if oprot.writeFieldBegin('algo', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.algo) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.config is not None:
      annotations = {}
      if oprot.writeFieldBegin('config', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.config) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.error is not None:
      annotations = {}
      if oprot.writeFieldBegin('error', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.error) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.state is not None:
      annotations = {}
      if oprot.writeFieldBegin('state', TType.MAP, 5, annotations) < 0: return -1
      if oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.state)) < 0: return -1
      for kiter7,viter8 in self.state.iteritems():
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(kiter7) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(viter8) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeMapEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.sigma is not None:
      annotations = {}
      if oprot.writeFieldBegin('sigma', TType.DOUBLE, 6, annotations) < 0: return -1
      if oprot.writeDouble(self.sigma) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.metric is not None:
      annotations = {}
      if oprot.writeFieldBegin('metric', TType.U64, 7, annotations) < 0: return -1
      if oprot.writeU64(self.metric) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.samples is not None:
      log_str.write('samples = ')
      log_str.write(str(self.samples))
      log_str.write('  ')
    if self.algo is not None:
      log_str.write('algo = ')
      log_str.write(self.algo)
      log_str.write('  ')
    if self.config is not None:
      log_str.write('config = ')
      log_str.write(self.config)
      log_str.write('  ')
    if self.error is not None:
      log_str.write('error = ')
      log_str.write(self.error)
      log_str.write('  ')
    if self.state is not None:
      log_str.write('state = ')
      log_str.write('{ ')
      for kiter9,viter10 in self.state.iteritems():
        log_str.write(kiter9)
        log_str.write(' : ')
        log_str.write(viter10)
      log_str.write(' }')
      log_str.write('  ')
    if self.sigma is not None:
      log_str.write('sigma = ')
      log_str.write(str(self.sigma))
      log_str.write('  ')
    if self.metric is not None:
      log_str.write('metric = ')
      log_str.write(str(self.metric))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.samples is not None:
      size += getsizeof(self.samples)
    if self.algo is not None:
      size += getsizeof(self.algo)
    if self.config is not None:
      size += getsizeof(self.config)
    if self.error is not None:
      size += getsizeof(self.error)
    if self.state is not None:
      size += getsizeof(self.state)
      size += sum(map(getsizeof, chain.from_iterable(self.state.iteritems())))
    if self.sigma is not None:
      size += getsizeof(self.sigma)
    if self.metric is not None:
      size += getsizeof(self.metric)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PercentileResult(object):
  """
  Attributes:
   - samples
   - percentiles
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    (3, TType.U64, 'samples', None, None, ), # 3
    (4, TType.MAP, 'percentiles', (TType.STRING,None,TType.DOUBLE,None), None, ), # 4
  )

  def __init__(self, samples=None, percentiles=None,):
    self.samples = samples
    self.percentiles = percentiles

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 3:
        if ftype == TType.U64:
          (length, self.samples) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.percentiles = {}
          (length, _ktype12, _vtype13, _size11 ) = iprot.readMapBegin() 
          read_cnt += length
          for _i15 in xrange(_size11):
            read_cnt += iprot.readContainerElementBegin()
            (length, _key16) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            read_cnt += iprot.readContainerElementBegin()
            (length, _val17) = iprot.readDouble();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            self.percentiles[_key16] = _val17
          read_cnt += iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.samples is not None:
      annotations = {}
      if oprot.writeFieldBegin('samples', TType.U64, 3, annotations) < 0: return -1
      if oprot.writeU64(self.samples) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.percentiles is not None:
      annotations = {}
      if oprot.writeFieldBegin('percentiles', TType.MAP, 4, annotations) < 0: return -1
      if oprot.writeMapBegin(TType.STRING, TType.DOUBLE, len(self.percentiles)) < 0: return -1
      for kiter18,viter19 in self.percentiles.iteritems():
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(kiter18) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeDouble(viter19) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeMapEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.samples is not None:
      log_str.write('samples = ')
      log_str.write(str(self.samples))
      log_str.write('  ')
    if self.percentiles is not None:
      log_str.write('percentiles = ')
      log_str.write('{ ')
      for kiter20,viter21 in self.percentiles.iteritems():
        log_str.write(kiter20)
        log_str.write(' : ')
        log_str.write(str(viter21))
      log_str.write(' }')
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.samples is not None:
      size += getsizeof(self.samples)
    if self.percentiles is not None:
      size += getsizeof(self.percentiles)
      size += sum(map(getsizeof, chain.from_iterable(self.percentiles.iteritems())))
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CategoryResult(object):
  """
  Attributes:
   - counters: @display_name:Sandesh Client Message Stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'counters', (TType.STRING,None,TType.U64,None), None, ), # 1
  )

  def __init__(self, counters=None,):
    self.counters = counters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.counters = {}
          (length, _ktype23, _vtype24, _size22 ) = iprot.readMapBegin() 
          read_cnt += length
          for _i26 in xrange(_size22):
            read_cnt += iprot.readContainerElementBegin()
            (length, _key27) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            read_cnt += iprot.readContainerElementBegin()
            (length, _val28) = iprot.readU64();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            self.counters[_key27] = _val28
          read_cnt += iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.counters is not None:
      annotations = {}
      annotations['tags'] = '.__key'
      if oprot.writeFieldBegin('counters', TType.MAP, 1, annotations) < 0: return -1
      if oprot.writeMapBegin(TType.STRING, TType.U64, len(self.counters)) < 0: return -1
      for kiter29,viter30 in self.counters.iteritems():
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(kiter29) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeU64(viter30) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeMapEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.counters is not None:
      log_str.write('counters = ')
      log_str.write('{ ')
      for kiter31,viter32 in self.counters.iteritems():
        log_str.write(kiter31)
        log_str.write(' : ')
        log_str.write(str(viter32))
      log_str.write(' }')
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.counters is not None:
      size += getsizeof(self.counters)
      size += sum(map(getsizeof, chain.from_iterable(self.counters.iteritems())))
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


_SANDESH_REQUEST_LIST = [
]


_SANDESH_UVE_LIST = [
]


_SANDESH_ALARM_LIST = [
]
