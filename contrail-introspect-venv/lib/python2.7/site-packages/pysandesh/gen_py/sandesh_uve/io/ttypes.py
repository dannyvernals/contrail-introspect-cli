#
# Autogenerated by Sandesh Compiler (1.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#

from pysandesh.Thrift import TType, TMessageType, TException

from pysandesh.transport import TTransport
from pysandesh.protocol import TBinaryProtocol, TProtocol
try:
  from pysandesh.protocol import fastbinary
except:
  fastbinary = None

import cStringIO
import uuid
import netaddr
from sys import getsizeof
from itertools import chain
import bottle
from pysandesh import sandesh_base
from pysandesh.sandesh_http import SandeshHttp
from pysandesh.sandesh_uve import SandeshUVETypeMaps
from pysandesh.util import UTCTimestampUsec, UTCTimestampUsecToString
from pysandesh import util
from pysandesh.gen_py.sandesh.constants import *



class SocketIOStats(object):
  """
  Statistics representing IO activity related to a socket

  Attributes:
   - bytes
   - calls
   - average_bytes
   - blocked_duration
   - blocked_count
   - average_blocked_duration
   - errors
  """

  thrift_spec = (
    None, # 0
    (1, TType.U64, 'bytes', None, None, ), # 1
    (2, TType.U64, 'calls', None, None, ), # 2
    (3, TType.DOUBLE, 'average_bytes', None, None, ), # 3
    (4, TType.STRING, 'blocked_duration', None, None, ), # 4
    (5, TType.U64, 'blocked_count', None, None, ), # 5
    (6, TType.STRING, 'average_blocked_duration', None, None, ), # 6
    (7, TType.U64, 'errors', None, None, ), # 7
  )

  def __init__(self, bytes=None, calls=None, average_bytes=None, blocked_duration=None, blocked_count=None, average_blocked_duration=None, errors=None,):
    self.bytes = bytes
    self.calls = calls
    self.average_bytes = average_bytes
    self.blocked_duration = blocked_duration
    self.blocked_count = blocked_count
    self.average_blocked_duration = average_blocked_duration
    self.errors = errors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U64:
          (length, self.bytes) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U64:
          (length, self.calls) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          (length, self.average_bytes) = iprot.readDouble();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.blocked_duration) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U64:
          (length, self.blocked_count) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          (length, self.average_blocked_duration) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.U64:
          (length, self.errors) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.bytes is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes', TType.U64, 1, annotations) < 0: return -1
      if oprot.writeU64(self.bytes) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.calls is not None:
      annotations = {}
      if oprot.writeFieldBegin('calls', TType.U64, 2, annotations) < 0: return -1
      if oprot.writeU64(self.calls) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.average_bytes is not None:
      annotations = {}
      if oprot.writeFieldBegin('average_bytes', TType.DOUBLE, 3, annotations) < 0: return -1
      if oprot.writeDouble(self.average_bytes) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.blocked_duration is not None:
      annotations = {}
      if oprot.writeFieldBegin('blocked_duration', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.blocked_duration) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.blocked_count is not None:
      annotations = {}
      if oprot.writeFieldBegin('blocked_count', TType.U64, 5, annotations) < 0: return -1
      if oprot.writeU64(self.blocked_count) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.average_blocked_duration is not None:
      annotations = {}
      if oprot.writeFieldBegin('average_blocked_duration', TType.STRING, 6, annotations) < 0: return -1
      if oprot.writeString(self.average_blocked_duration) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.errors is not None:
      annotations = {}
      if oprot.writeFieldBegin('errors', TType.U64, 7, annotations) < 0: return -1
      if oprot.writeU64(self.errors) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.bytes is not None:
      log_str.write('bytes = ')
      log_str.write(str(self.bytes))
      log_str.write('  ')
    if self.calls is not None:
      log_str.write('calls = ')
      log_str.write(str(self.calls))
      log_str.write('  ')
    if self.average_bytes is not None:
      log_str.write('average_bytes = ')
      log_str.write(str(self.average_bytes))
      log_str.write('  ')
    if self.blocked_duration is not None:
      log_str.write('blocked_duration = ')
      log_str.write(self.blocked_duration)
      log_str.write('  ')
    if self.blocked_count is not None:
      log_str.write('blocked_count = ')
      log_str.write(str(self.blocked_count))
      log_str.write('  ')
    if self.average_blocked_duration is not None:
      log_str.write('average_blocked_duration = ')
      log_str.write(self.average_blocked_duration)
      log_str.write('  ')
    if self.errors is not None:
      log_str.write('errors = ')
      log_str.write(str(self.errors))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.bytes is not None:
      size += getsizeof(self.bytes)
    if self.calls is not None:
      size += getsizeof(self.calls)
    if self.average_bytes is not None:
      size += getsizeof(self.average_bytes)
    if self.blocked_duration is not None:
      size += getsizeof(self.blocked_duration)
    if self.blocked_count is not None:
      size += getsizeof(self.blocked_count)
    if self.average_blocked_duration is not None:
      size += getsizeof(self.average_blocked_duration)
    if self.errors is not None:
      size += getsizeof(self.errors)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SocketEndpointMessageStats(object):
  """
  Statistics representing IO activitiy related to a particular
  message on an endpoint

  Attributes:
   - endpoint_name
   - message_name
   - messages
   - bytes
   - errors
   - last_timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'endpoint_name', None, None, ), # 1
    (2, TType.STRING, 'message_name', None, None, ), # 2
    (3, TType.U64, 'messages', None, None, ), # 3
    (4, TType.U64, 'bytes', None, None, ), # 4
    (5, TType.U64, 'errors', None, None, ), # 5
    (6, TType.U64, 'last_timestamp', None, None, ), # 6
  )

  def __init__(self, endpoint_name=None, message_name=None, messages=None, bytes=None, errors=None, last_timestamp=None,):
    self.endpoint_name = endpoint_name
    self.message_name = message_name
    self.messages = messages
    self.bytes = bytes
    self.errors = errors
    self.last_timestamp = last_timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.endpoint_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.message_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U64:
          (length, self.messages) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U64:
          (length, self.bytes) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U64:
          (length, self.errors) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.U64:
          (length, self.last_timestamp) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.endpoint_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('endpoint_name', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.endpoint_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.message_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('message_name', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.message_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages', TType.U64, 3, annotations) < 0: return -1
      if oprot.writeU64(self.messages) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes', TType.U64, 4, annotations) < 0: return -1
      if oprot.writeU64(self.bytes) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.errors is not None:
      annotations = {}
      if oprot.writeFieldBegin('errors', TType.U64, 5, annotations) < 0: return -1
      if oprot.writeU64(self.errors) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.last_timestamp is not None:
      annotations = {}
      if oprot.writeFieldBegin('last_timestamp', TType.U64, 6, annotations) < 0: return -1
      if oprot.writeU64(self.last_timestamp) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.endpoint_name is not None:
      log_str.write('endpoint_name = ')
      log_str.write(self.endpoint_name)
      log_str.write('  ')
    if self.message_name is not None:
      log_str.write('message_name = ')
      log_str.write(self.message_name)
      log_str.write('  ')
    if self.messages is not None:
      log_str.write('messages = ')
      log_str.write(str(self.messages))
      log_str.write('  ')
    if self.bytes is not None:
      log_str.write('bytes = ')
      log_str.write(str(self.bytes))
      log_str.write('  ')
    if self.errors is not None:
      log_str.write('errors = ')
      log_str.write(str(self.errors))
      log_str.write('  ')
    if self.last_timestamp is not None:
      log_str.write('last_timestamp = ')
      log_str.write(str(self.last_timestamp))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.endpoint_name is not None:
      size += getsizeof(self.endpoint_name)
    if self.message_name is not None:
      size += getsizeof(self.message_name)
    if self.messages is not None:
      size += getsizeof(self.messages)
    if self.bytes is not None:
      size += getsizeof(self.bytes)
    if self.errors is not None:
      size += getsizeof(self.errors)
    if self.last_timestamp is not None:
      size += getsizeof(self.last_timestamp)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventManagerMessageTrace(sandesh_base.SandeshTrace):

  thrift_spec = None

  def __init__(self, Message=None, file=None, line=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshTrace.__init__(self, type=SandeshType.TRACE)
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2183673535
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventManagerMessageLog(sandesh_base.SandeshSystem):

  thrift_spec = None

  rate_limit_buffer = util.deque(maxlen=sandesh_base.SandeshSystem._DEFAULT_SEND_RATELIMIT)

  do_rate_limit_drop_log = True

  def __init__(self, Message=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshSystem.__init__(self)
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2183673535
    self._hints = 0
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TcpMessageTrace(sandesh_base.SandeshTrace):

  thrift_spec = None

  def __init__(self, Direction=None, Message=None, file=None, line=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshTrace.__init__(self, type=SandeshType.TRACE)
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 347093776
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TcpMessageLog(sandesh_base.SandeshSystem):

  thrift_spec = None

  rate_limit_buffer = util.deque(maxlen=sandesh_base.SandeshSystem._DEFAULT_SEND_RATELIMIT)

  do_rate_limit_drop_log = True

  def __init__(self, Direction=None, Message=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshSystem.__init__(self)
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 347093776
    self._hints = 0
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TcpServerMessageTrace(sandesh_base.SandeshTrace):

  thrift_spec = None

  def __init__(self, ServerName=None, Direction=None, Message=None, file=None, line=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshTrace.__init__(self, type=SandeshType.TRACE)
    self.str1 = "Server"
    self.ServerName = ServerName
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 4159623157
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.str1 is not None:
      log_str.write(self.str1)
      log_str.write('  ')
    if self.ServerName is not None:
      log_str.write(self.ServerName)
      log_str.write('  ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.str1) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.ServerName) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.str1 is not None:
      annotations = {}
      if oprot.writeFieldBegin('str1', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.str1) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.ServerName is not None:
      annotations = {}
      if oprot.writeFieldBegin('ServerName', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.ServerName) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    if self.str1 is None:
      raise TProtocol.TProtocolException(message='Required field str1 is unset!')
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.str1 != other.str1:
      return False
    if self.ServerName != other.ServerName:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.str1 is not None:
      size += getsizeof(self.str1)
    if self.ServerName is not None:
      size += getsizeof(self.ServerName)
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TcpServerMessageLog(sandesh_base.SandeshSystem):

  thrift_spec = None

  rate_limit_buffer = util.deque(maxlen=sandesh_base.SandeshSystem._DEFAULT_SEND_RATELIMIT)

  do_rate_limit_drop_log = True

  def __init__(self, ServerName=None, Direction=None, Message=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshSystem.__init__(self)
    self.str1 = "Server"
    self.ServerName = ServerName
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 4159623157
    self._hints = 0
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.str1 is not None:
      log_str.write(self.str1)
      log_str.write('  ')
    if self.ServerName is not None:
      log_str.write(self.ServerName)
      log_str.write('  ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.str1) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.ServerName) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.str1 is not None:
      annotations = {}
      if oprot.writeFieldBegin('str1', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.str1) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.ServerName is not None:
      annotations = {}
      if oprot.writeFieldBegin('ServerName', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.ServerName) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    if self.str1 is None:
      raise TProtocol.TProtocolException(message='Required field str1 is unset!')
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.str1 != other.str1:
      return False
    if self.ServerName != other.ServerName:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.str1 is not None:
      size += getsizeof(self.str1)
    if self.ServerName is not None:
      size += getsizeof(self.ServerName)
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TcpSessionMessageTrace(sandesh_base.SandeshTrace):

  thrift_spec = None

  def __init__(self, SessionName=None, Direction=None, Message=None, file=None, line=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshTrace.__init__(self, type=SandeshType.TRACE)
    self.str1 = "Session"
    self.SessionName = SessionName
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 4159623157
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.str1 is not None:
      log_str.write(self.str1)
      log_str.write('  ')
    if self.SessionName is not None:
      log_str.write(self.SessionName)
      log_str.write('  ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.str1) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.SessionName) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.str1 is not None:
      annotations = {}
      if oprot.writeFieldBegin('str1', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.str1) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.SessionName is not None:
      annotations = {}
      if oprot.writeFieldBegin('SessionName', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.SessionName) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    if self.str1 is None:
      raise TProtocol.TProtocolException(message='Required field str1 is unset!')
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.str1 != other.str1:
      return False
    if self.SessionName != other.SessionName:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.str1 is not None:
      size += getsizeof(self.str1)
    if self.SessionName is not None:
      size += getsizeof(self.SessionName)
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TcpSessionMessageLog(sandesh_base.SandeshSystem):

  thrift_spec = None

  rate_limit_buffer = util.deque(maxlen=sandesh_base.SandeshSystem._DEFAULT_SEND_RATELIMIT)

  do_rate_limit_drop_log = True

  def __init__(self, SessionName=None, Direction=None, Message=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshSystem.__init__(self)
    self.str1 = "Session"
    self.SessionName = SessionName
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 4159623157
    self._hints = 0
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.str1 is not None:
      log_str.write(self.str1)
      log_str.write('  ')
    if self.SessionName is not None:
      log_str.write(self.SessionName)
      log_str.write('  ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.str1) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.SessionName) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.str1 is not None:
      annotations = {}
      if oprot.writeFieldBegin('str1', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.str1) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.SessionName is not None:
      annotations = {}
      if oprot.writeFieldBegin('SessionName', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.SessionName) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    if self.str1 is None:
      raise TProtocol.TProtocolException(message='Required field str1 is unset!')
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.str1 != other.str1:
      return False
    if self.SessionName != other.SessionName:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.str1 is not None:
      size += getsizeof(self.str1)
    if self.SessionName is not None:
      size += getsizeof(self.SessionName)
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UdpMessageTrace(sandesh_base.SandeshTrace):

  thrift_spec = None

  def __init__(self, Direction=None, Message=None, file=None, line=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshTrace.__init__(self, type=SandeshType.TRACE)
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 347093776
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UdpMessageLog(sandesh_base.SandeshSystem):

  thrift_spec = None

  rate_limit_buffer = util.deque(maxlen=sandesh_base.SandeshSystem._DEFAULT_SEND_RATELIMIT)

  do_rate_limit_drop_log = True

  def __init__(self, Direction=None, Message=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshSystem.__init__(self)
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 347093776
    self._hints = 0
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UdpServerMessageTrace(sandesh_base.SandeshTrace):

  thrift_spec = None

  def __init__(self, ServerName=None, Direction=None, Message=None, file=None, line=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshTrace.__init__(self, type=SandeshType.TRACE)
    self.str1 = "Server"
    self.ServerName = ServerName
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 4159623157
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.str1 is not None:
      log_str.write(self.str1)
      log_str.write('  ')
    if self.ServerName is not None:
      log_str.write(self.ServerName)
      log_str.write('  ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.str1) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.ServerName) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.str1 is not None:
      annotations = {}
      if oprot.writeFieldBegin('str1', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.str1) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.ServerName is not None:
      annotations = {}
      if oprot.writeFieldBegin('ServerName', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.ServerName) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    if self.str1 is None:
      raise TProtocol.TProtocolException(message='Required field str1 is unset!')
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.str1 != other.str1:
      return False
    if self.ServerName != other.ServerName:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.str1 is not None:
      size += getsizeof(self.str1)
    if self.ServerName is not None:
      size += getsizeof(self.ServerName)
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UdpServerMessageLog(sandesh_base.SandeshSystem):

  thrift_spec = None

  rate_limit_buffer = util.deque(maxlen=sandesh_base.SandeshSystem._DEFAULT_SEND_RATELIMIT)

  do_rate_limit_drop_log = True

  def __init__(self, ServerName=None, Direction=None, Message=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshSystem.__init__(self)
    self.str1 = "Server"
    self.ServerName = ServerName
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 4159623157
    self._hints = 0
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.str1 is not None:
      log_str.write(self.str1)
      log_str.write('  ')
    if self.ServerName is not None:
      log_str.write(self.ServerName)
      log_str.write('  ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.str1) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.ServerName) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.str1 is not None:
      annotations = {}
      if oprot.writeFieldBegin('str1', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.str1) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.ServerName is not None:
      annotations = {}
      if oprot.writeFieldBegin('ServerName', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.ServerName) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    if self.str1 is None:
      raise TProtocol.TProtocolException(message='Required field str1 is unset!')
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.str1 != other.str1:
      return False
    if self.ServerName != other.ServerName:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.str1 is not None:
      size += getsizeof(self.str1)
    if self.ServerName is not None:
      size += getsizeof(self.ServerName)
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UdpSessionMessageTrace(sandesh_base.SandeshTrace):

  thrift_spec = None

  def __init__(self, SessionName=None, Direction=None, Message=None, file=None, line=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshTrace.__init__(self, type=SandeshType.TRACE)
    self.str1 = "Session"
    self.SessionName = SessionName
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 4159623157
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.str1 is not None:
      log_str.write(self.str1)
      log_str.write('  ')
    if self.SessionName is not None:
      log_str.write(self.SessionName)
      log_str.write('  ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.str1) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.SessionName) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.str1 is not None:
      annotations = {}
      if oprot.writeFieldBegin('str1', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.str1) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.SessionName is not None:
      annotations = {}
      if oprot.writeFieldBegin('SessionName', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.SessionName) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    if self.str1 is None:
      raise TProtocol.TProtocolException(message='Required field str1 is unset!')
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.str1 != other.str1:
      return False
    if self.SessionName != other.SessionName:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.str1 is not None:
      size += getsizeof(self.str1)
    if self.SessionName is not None:
      size += getsizeof(self.SessionName)
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UdpSessionMessageLog(sandesh_base.SandeshSystem):

  thrift_spec = None

  rate_limit_buffer = util.deque(maxlen=sandesh_base.SandeshSystem._DEFAULT_SEND_RATELIMIT)

  do_rate_limit_drop_log = True

  def __init__(self, SessionName=None, Direction=None, Message=None, file=None, line=None, category='__default__', level=SandeshLevel.SYS_INFO, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshSystem.__init__(self)
    self.str1 = "Session"
    self.SessionName = SessionName
    self.Direction = Direction
    self.Message = Message
    self.file = file
    self.line = line
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 4159623157
    self._hints = 0
    self._category = category
    self._level = level

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    if self._category is not None:
      log_str.write(self._category)
    log_str.write(' [')
    log_str.write(SandeshLevel._VALUES_TO_NAMES[self._level])
    log_str.write(']: ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.str1 is not None:
      log_str.write(self.str1)
      log_str.write('  ')
    if self.SessionName is not None:
      log_str.write(self.SessionName)
      log_str.write('  ')
    if self.Direction is not None:
      log_str.write(self.Direction)
      log_str.write('  ')
    if self.Message is not None:
      log_str.write(self.Message)
      log_str.write('  ')
    if self.file is not None:
      log_str.write(self.file)
      log_str.write('  ')
    if self.line is not None:
      log_str.write(str(self.line))
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.str1) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.SessionName) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.Direction) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.Message) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32768:
        if ftype == TType.STRING:
          (length, self.file) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == -32767:
        if ftype == TType.I32:
          (length, self.line) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.file is not None:
      annotations = {}
      if oprot.writeFieldBegin('file', TType.STRING, -32768, annotations) < 0: return -1
      if oprot.writeString(self.file) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.line is not None:
      annotations = {}
      if oprot.writeFieldBegin('line', TType.I32, -32767, annotations) < 0: return -1
      if oprot.writeI32(self.line) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.str1 is not None:
      annotations = {}
      if oprot.writeFieldBegin('str1', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.str1) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.SessionName is not None:
      annotations = {}
      if oprot.writeFieldBegin('SessionName', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.SessionName) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Direction is not None:
      annotations = {}
      if oprot.writeFieldBegin('Direction', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.Direction) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.Message is not None:
      annotations = {}
      if oprot.writeFieldBegin('Message', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.Message) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    if self.str1 is None:
      raise TProtocol.TProtocolException(message='Required field str1 is unset!')
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.file != other.file:
      return False
    if self.line != other.line:
      return False
    if self.str1 != other.str1:
      return False
    if self.SessionName != other.SessionName:
      return False
    if self.Direction != other.Direction:
      return False
    if self.Message != other.Message:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.str1 is not None:
      size += getsizeof(self.str1)
    if self.SessionName is not None:
      size += getsizeof(self.SessionName)
    if self.Direction is not None:
      size += getsizeof(self.Direction)
    if self.Message is not None:
      size += getsizeof(self.Message)
    if self.file is not None:
      size += getsizeof(self.file)
    if self.line is not None:
      size += getsizeof(self.line)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


_SANDESH_REQUEST_LIST = [
]


_SANDESH_UVE_LIST = [
]


_SANDESH_ALARM_LIST = [
]
