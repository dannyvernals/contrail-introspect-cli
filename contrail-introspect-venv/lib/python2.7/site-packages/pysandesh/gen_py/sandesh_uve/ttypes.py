#
# Autogenerated by Sandesh Compiler (1.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#

from pysandesh.Thrift import TType, TMessageType, TException
import io.ttypes
import derived_stats_results.ttypes


from pysandesh.transport import TTransport
from pysandesh.protocol import TBinaryProtocol, TProtocol
try:
  from pysandesh.protocol import fastbinary
except:
  fastbinary = None

import cStringIO
import uuid
import netaddr
from sys import getsizeof
from itertools import chain
import bottle
from pysandesh import sandesh_base
from pysandesh.sandesh_http import SandeshHttp
from pysandesh.sandesh_uve import SandeshUVETypeMaps
from pysandesh.util import UTCTimestampUsec, UTCTimestampUsecToString
from pysandesh import util
from pysandesh.gen_py.sandesh.constants import *



class SandeshMessageStats(object):
  """
  Attributes:
   - messages_sent
   - bytes_sent
   - messages_received
   - bytes_received
   - messages_sent_dropped
   - bytes_sent_dropped
   - messages_received_dropped
   - bytes_received_dropped
   - messages_sent_dropped_no_queue
   - messages_sent_dropped_no_client
   - messages_sent_dropped_no_session
   - messages_sent_dropped_queue_level
   - messages_sent_dropped_client_send_failed
   - messages_sent_dropped_session_not_connected
   - messages_sent_dropped_header_write_failed
   - messages_sent_dropped_write_failed
   - messages_sent_dropped_wrong_client_sm_state
   - messages_sent_dropped_validation_failed
   - messages_sent_dropped_rate_limited
   - messages_sent_dropped_sending_disabled
   - messages_sent_dropped_sending_to_syslog
   - bytes_sent_dropped_no_queue
   - bytes_sent_dropped_no_client
   - bytes_sent_dropped_no_session
   - bytes_sent_dropped_queue_level
   - bytes_sent_dropped_client_send_failed
   - bytes_sent_dropped_session_not_connected
   - bytes_sent_dropped_header_write_failed
   - bytes_sent_dropped_write_failed
   - bytes_sent_dropped_wrong_client_sm_state
   - bytes_sent_dropped_validation_failed
   - bytes_sent_dropped_rate_limited
   - bytes_sent_dropped_sending_disabled
   - bytes_sent_dropped_sending_to_syslog
   - messages_received_dropped_no_queue
   - messages_received_dropped_queue_level
   - messages_received_dropped_create_failed
   - messages_received_dropped_control_msg_failed
   - messages_received_dropped_decoding_failed
   - bytes_received_dropped_no_queue
   - bytes_received_dropped_queue_level
   - bytes_received_dropped_create_failed
   - bytes_received_dropped_control_msg_failed
   - bytes_received_dropped_decoding_failed
  """

  thrift_spec = (
    None, # 0
    (1, TType.U64, 'messages_sent', None, None, ), # 1
    (2, TType.U64, 'bytes_sent', None, None, ), # 2
    (3, TType.U64, 'messages_received', None, None, ), # 3
    (4, TType.U64, 'bytes_received', None, None, ), # 4
    (5, TType.U64, 'messages_sent_dropped', None, None, ), # 5
    (6, TType.U64, 'bytes_sent_dropped', None, None, ), # 6
    (7, TType.U64, 'messages_received_dropped', None, None, ), # 7
    (8, TType.U64, 'bytes_received_dropped', None, None, ), # 8
    None, # 9
    None, # 10
    None, # 11
    None, # 12
    None, # 13
    None, # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    None, # 20
    None, # 21
    None, # 22
    None, # 23
    None, # 24
    None, # 25
    None, # 26
    None, # 27
    None, # 28
    None, # 29
    None, # 30
    None, # 31
    None, # 32
    None, # 33
    None, # 34
    None, # 35
    None, # 36
    None, # 37
    None, # 38
    None, # 39
    None, # 40
    None, # 41
    None, # 42
    None, # 43
    None, # 44
    None, # 45
    None, # 46
    None, # 47
    None, # 48
    None, # 49
    None, # 50
    (51, TType.U64, 'messages_sent_dropped_no_queue', None, None, ), # 51
    (52, TType.U64, 'messages_sent_dropped_no_client', None, None, ), # 52
    (53, TType.U64, 'messages_sent_dropped_no_session', None, None, ), # 53
    (54, TType.U64, 'messages_sent_dropped_queue_level', None, None, ), # 54
    (55, TType.U64, 'messages_sent_dropped_client_send_failed', None, None, ), # 55
    (56, TType.U64, 'messages_sent_dropped_session_not_connected', None, None, ), # 56
    (57, TType.U64, 'messages_sent_dropped_header_write_failed', None, None, ), # 57
    (58, TType.U64, 'messages_sent_dropped_write_failed', None, None, ), # 58
    (59, TType.U64, 'messages_sent_dropped_wrong_client_sm_state', None, None, ), # 59
    (60, TType.U64, 'messages_sent_dropped_validation_failed', None, None, ), # 60
    (61, TType.U64, 'messages_sent_dropped_rate_limited', None, None, ), # 61
    (62, TType.U64, 'messages_sent_dropped_sending_disabled', None, None, ), # 62
    (63, TType.U64, 'messages_sent_dropped_sending_to_syslog', None, None, ), # 63
    None, # 64
    None, # 65
    None, # 66
    None, # 67
    None, # 68
    None, # 69
    None, # 70
    None, # 71
    None, # 72
    None, # 73
    None, # 74
    None, # 75
    None, # 76
    None, # 77
    None, # 78
    None, # 79
    None, # 80
    (81, TType.U64, 'bytes_sent_dropped_no_queue', None, None, ), # 81
    (82, TType.U64, 'bytes_sent_dropped_no_client', None, None, ), # 82
    (83, TType.U64, 'bytes_sent_dropped_no_session', None, None, ), # 83
    (84, TType.U64, 'bytes_sent_dropped_queue_level', None, None, ), # 84
    (85, TType.U64, 'bytes_sent_dropped_client_send_failed', None, None, ), # 85
    (86, TType.U64, 'bytes_sent_dropped_session_not_connected', None, None, ), # 86
    (87, TType.U64, 'bytes_sent_dropped_header_write_failed', None, None, ), # 87
    (88, TType.U64, 'bytes_sent_dropped_write_failed', None, None, ), # 88
    (89, TType.U64, 'bytes_sent_dropped_wrong_client_sm_state', None, None, ), # 89
    (90, TType.U64, 'bytes_sent_dropped_validation_failed', None, None, ), # 90
    (91, TType.U64, 'bytes_sent_dropped_rate_limited', None, None, ), # 91
    (92, TType.U64, 'bytes_sent_dropped_sending_disabled', None, None, ), # 92
    (93, TType.U64, 'bytes_sent_dropped_sending_to_syslog', None, None, ), # 93
    None, # 94
    None, # 95
    None, # 96
    None, # 97
    None, # 98
    None, # 99
    None, # 100
    (101, TType.U64, 'messages_received_dropped_no_queue', None, None, ), # 101
    (102, TType.U64, 'messages_received_dropped_queue_level', None, None, ), # 102
    (103, TType.U64, 'messages_received_dropped_create_failed', None, None, ), # 103
    (104, TType.U64, 'messages_received_dropped_control_msg_failed', None, None, ), # 104
    (105, TType.U64, 'messages_received_dropped_decoding_failed', None, None, ), # 105
    None, # 106
    None, # 107
    None, # 108
    None, # 109
    None, # 110
    None, # 111
    None, # 112
    None, # 113
    None, # 114
    None, # 115
    None, # 116
    None, # 117
    None, # 118
    None, # 119
    None, # 120
    None, # 121
    None, # 122
    None, # 123
    None, # 124
    None, # 125
    None, # 126
    None, # 127
    None, # 128
    None, # 129
    None, # 130
    (131, TType.U64, 'bytes_received_dropped_no_queue', None, None, ), # 131
    (132, TType.U64, 'bytes_received_dropped_queue_level', None, None, ), # 132
    (133, TType.U64, 'bytes_received_dropped_create_failed', None, None, ), # 133
    (134, TType.U64, 'bytes_received_dropped_control_msg_failed', None, None, ), # 134
    (135, TType.U64, 'bytes_received_dropped_decoding_failed', None, None, ), # 135
  )

  def __init__(self, messages_sent=None, bytes_sent=None, messages_received=None, bytes_received=None, messages_sent_dropped=None, bytes_sent_dropped=None, messages_received_dropped=None, bytes_received_dropped=None, messages_sent_dropped_no_queue=None, messages_sent_dropped_no_client=None, messages_sent_dropped_no_session=None, messages_sent_dropped_queue_level=None, messages_sent_dropped_client_send_failed=None, messages_sent_dropped_session_not_connected=None, messages_sent_dropped_header_write_failed=None, messages_sent_dropped_write_failed=None, messages_sent_dropped_wrong_client_sm_state=None, messages_sent_dropped_validation_failed=None, messages_sent_dropped_rate_limited=None, messages_sent_dropped_sending_disabled=None, messages_sent_dropped_sending_to_syslog=None, bytes_sent_dropped_no_queue=None, bytes_sent_dropped_no_client=None, bytes_sent_dropped_no_session=None, bytes_sent_dropped_queue_level=None, bytes_sent_dropped_client_send_failed=None, bytes_sent_dropped_session_not_connected=None, bytes_sent_dropped_header_write_failed=None, bytes_sent_dropped_write_failed=None, bytes_sent_dropped_wrong_client_sm_state=None, bytes_sent_dropped_validation_failed=None, bytes_sent_dropped_rate_limited=None, bytes_sent_dropped_sending_disabled=None, bytes_sent_dropped_sending_to_syslog=None, messages_received_dropped_no_queue=None, messages_received_dropped_queue_level=None, messages_received_dropped_create_failed=None, messages_received_dropped_control_msg_failed=None, messages_received_dropped_decoding_failed=None, bytes_received_dropped_no_queue=None, bytes_received_dropped_queue_level=None, bytes_received_dropped_create_failed=None, bytes_received_dropped_control_msg_failed=None, bytes_received_dropped_decoding_failed=None,):
    self.messages_sent = messages_sent
    self.bytes_sent = bytes_sent
    self.messages_received = messages_received
    self.bytes_received = bytes_received
    self.messages_sent_dropped = messages_sent_dropped
    self.bytes_sent_dropped = bytes_sent_dropped
    self.messages_received_dropped = messages_received_dropped
    self.bytes_received_dropped = bytes_received_dropped
    self.messages_sent_dropped_no_queue = messages_sent_dropped_no_queue
    self.messages_sent_dropped_no_client = messages_sent_dropped_no_client
    self.messages_sent_dropped_no_session = messages_sent_dropped_no_session
    self.messages_sent_dropped_queue_level = messages_sent_dropped_queue_level
    self.messages_sent_dropped_client_send_failed = messages_sent_dropped_client_send_failed
    self.messages_sent_dropped_session_not_connected = messages_sent_dropped_session_not_connected
    self.messages_sent_dropped_header_write_failed = messages_sent_dropped_header_write_failed
    self.messages_sent_dropped_write_failed = messages_sent_dropped_write_failed
    self.messages_sent_dropped_wrong_client_sm_state = messages_sent_dropped_wrong_client_sm_state
    self.messages_sent_dropped_validation_failed = messages_sent_dropped_validation_failed
    self.messages_sent_dropped_rate_limited = messages_sent_dropped_rate_limited
    self.messages_sent_dropped_sending_disabled = messages_sent_dropped_sending_disabled
    self.messages_sent_dropped_sending_to_syslog = messages_sent_dropped_sending_to_syslog
    self.bytes_sent_dropped_no_queue = bytes_sent_dropped_no_queue
    self.bytes_sent_dropped_no_client = bytes_sent_dropped_no_client
    self.bytes_sent_dropped_no_session = bytes_sent_dropped_no_session
    self.bytes_sent_dropped_queue_level = bytes_sent_dropped_queue_level
    self.bytes_sent_dropped_client_send_failed = bytes_sent_dropped_client_send_failed
    self.bytes_sent_dropped_session_not_connected = bytes_sent_dropped_session_not_connected
    self.bytes_sent_dropped_header_write_failed = bytes_sent_dropped_header_write_failed
    self.bytes_sent_dropped_write_failed = bytes_sent_dropped_write_failed
    self.bytes_sent_dropped_wrong_client_sm_state = bytes_sent_dropped_wrong_client_sm_state
    self.bytes_sent_dropped_validation_failed = bytes_sent_dropped_validation_failed
    self.bytes_sent_dropped_rate_limited = bytes_sent_dropped_rate_limited
    self.bytes_sent_dropped_sending_disabled = bytes_sent_dropped_sending_disabled
    self.bytes_sent_dropped_sending_to_syslog = bytes_sent_dropped_sending_to_syslog
    self.messages_received_dropped_no_queue = messages_received_dropped_no_queue
    self.messages_received_dropped_queue_level = messages_received_dropped_queue_level
    self.messages_received_dropped_create_failed = messages_received_dropped_create_failed
    self.messages_received_dropped_control_msg_failed = messages_received_dropped_control_msg_failed
    self.messages_received_dropped_decoding_failed = messages_received_dropped_decoding_failed
    self.bytes_received_dropped_no_queue = bytes_received_dropped_no_queue
    self.bytes_received_dropped_queue_level = bytes_received_dropped_queue_level
    self.bytes_received_dropped_create_failed = bytes_received_dropped_create_failed
    self.bytes_received_dropped_control_msg_failed = bytes_received_dropped_control_msg_failed
    self.bytes_received_dropped_decoding_failed = bytes_received_dropped_decoding_failed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U64:
          (length, self.messages_sent) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U64:
          (length, self.bytes_sent) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U64:
          (length, self.messages_received) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U64:
          (length, self.bytes_received) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.U64:
          (length, self.messages_received_dropped) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.U64:
          (length, self.bytes_received_dropped) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 51:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_no_queue) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 52:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_no_client) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 53:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_no_session) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 54:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_queue_level) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 55:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_client_send_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 56:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_session_not_connected) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 57:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_header_write_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 58:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_write_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 59:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_wrong_client_sm_state) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 60:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_validation_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 61:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_rate_limited) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 62:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_sending_disabled) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 63:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped_sending_to_syslog) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 81:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_no_queue) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 82:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_no_client) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 83:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_no_session) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 84:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_queue_level) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 85:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_client_send_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 86:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_session_not_connected) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 87:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_header_write_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 88:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_write_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 89:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_wrong_client_sm_state) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 90:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_validation_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 91:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_rate_limited) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 92:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_sending_disabled) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 93:
        if ftype == TType.U64:
          (length, self.bytes_sent_dropped_sending_to_syslog) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 101:
        if ftype == TType.U64:
          (length, self.messages_received_dropped_no_queue) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 102:
        if ftype == TType.U64:
          (length, self.messages_received_dropped_queue_level) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 103:
        if ftype == TType.U64:
          (length, self.messages_received_dropped_create_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 104:
        if ftype == TType.U64:
          (length, self.messages_received_dropped_control_msg_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 105:
        if ftype == TType.U64:
          (length, self.messages_received_dropped_decoding_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 131:
        if ftype == TType.U64:
          (length, self.bytes_received_dropped_no_queue) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 132:
        if ftype == TType.U64:
          (length, self.bytes_received_dropped_queue_level) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 133:
        if ftype == TType.U64:
          (length, self.bytes_received_dropped_create_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 134:
        if ftype == TType.U64:
          (length, self.bytes_received_dropped_control_msg_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 135:
        if ftype == TType.U64:
          (length, self.bytes_received_dropped_decoding_failed) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.messages_sent is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent', TType.U64, 1, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent', TType.U64, 2, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_received is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_received', TType.U64, 3, annotations) < 0: return -1
      if oprot.writeU64(self.messages_received) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_received is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_received', TType.U64, 4, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_received) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped', TType.U64, 5, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped', TType.U64, 6, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_received_dropped is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_received_dropped', TType.U64, 7, annotations) < 0: return -1
      if oprot.writeU64(self.messages_received_dropped) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_received_dropped is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_received_dropped', TType.U64, 8, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_received_dropped) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_no_queue is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_no_queue', TType.U64, 51, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_no_queue) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_no_client is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_no_client', TType.U64, 52, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_no_client) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_no_session is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_no_session', TType.U64, 53, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_no_session) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_queue_level is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_queue_level', TType.U64, 54, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_queue_level) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_client_send_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_client_send_failed', TType.U64, 55, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_client_send_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_session_not_connected is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_session_not_connected', TType.U64, 56, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_session_not_connected) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_header_write_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_header_write_failed', TType.U64, 57, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_header_write_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_write_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_write_failed', TType.U64, 58, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_write_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_wrong_client_sm_state is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_wrong_client_sm_state', TType.U64, 59, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_wrong_client_sm_state) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_validation_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_validation_failed', TType.U64, 60, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_validation_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_rate_limited is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_rate_limited', TType.U64, 61, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_rate_limited) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_sending_disabled is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_sending_disabled', TType.U64, 62, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_sending_disabled) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped_sending_to_syslog is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped_sending_to_syslog', TType.U64, 63, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped_sending_to_syslog) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_no_queue is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_no_queue', TType.U64, 81, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_no_queue) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_no_client is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_no_client', TType.U64, 82, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_no_client) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_no_session is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_no_session', TType.U64, 83, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_no_session) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_queue_level is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_queue_level', TType.U64, 84, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_queue_level) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_client_send_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_client_send_failed', TType.U64, 85, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_client_send_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_session_not_connected is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_session_not_connected', TType.U64, 86, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_session_not_connected) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_header_write_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_header_write_failed', TType.U64, 87, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_header_write_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_write_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_write_failed', TType.U64, 88, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_write_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_wrong_client_sm_state is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_wrong_client_sm_state', TType.U64, 89, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_wrong_client_sm_state) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_validation_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_validation_failed', TType.U64, 90, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_validation_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_rate_limited is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_rate_limited', TType.U64, 91, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_rate_limited) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_sending_disabled is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_sending_disabled', TType.U64, 92, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_sending_disabled) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent_dropped_sending_to_syslog is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent_dropped_sending_to_syslog', TType.U64, 93, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent_dropped_sending_to_syslog) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_received_dropped_no_queue is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_received_dropped_no_queue', TType.U64, 101, annotations) < 0: return -1
      if oprot.writeU64(self.messages_received_dropped_no_queue) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_received_dropped_queue_level is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_received_dropped_queue_level', TType.U64, 102, annotations) < 0: return -1
      if oprot.writeU64(self.messages_received_dropped_queue_level) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_received_dropped_create_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_received_dropped_create_failed', TType.U64, 103, annotations) < 0: return -1
      if oprot.writeU64(self.messages_received_dropped_create_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_received_dropped_control_msg_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_received_dropped_control_msg_failed', TType.U64, 104, annotations) < 0: return -1
      if oprot.writeU64(self.messages_received_dropped_control_msg_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_received_dropped_decoding_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_received_dropped_decoding_failed', TType.U64, 105, annotations) < 0: return -1
      if oprot.writeU64(self.messages_received_dropped_decoding_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_received_dropped_no_queue is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_received_dropped_no_queue', TType.U64, 131, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_received_dropped_no_queue) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_received_dropped_queue_level is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_received_dropped_queue_level', TType.U64, 132, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_received_dropped_queue_level) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_received_dropped_create_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_received_dropped_create_failed', TType.U64, 133, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_received_dropped_create_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_received_dropped_control_msg_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_received_dropped_control_msg_failed', TType.U64, 134, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_received_dropped_control_msg_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_received_dropped_decoding_failed is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_received_dropped_decoding_failed', TType.U64, 135, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_received_dropped_decoding_failed) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.messages_sent is not None:
      log_str.write('messages_sent = ')
      log_str.write(str(self.messages_sent))
      log_str.write('  ')
    if self.bytes_sent is not None:
      log_str.write('bytes_sent = ')
      log_str.write(str(self.bytes_sent))
      log_str.write('  ')
    if self.messages_received is not None:
      log_str.write('messages_received = ')
      log_str.write(str(self.messages_received))
      log_str.write('  ')
    if self.bytes_received is not None:
      log_str.write('bytes_received = ')
      log_str.write(str(self.bytes_received))
      log_str.write('  ')
    if self.messages_sent_dropped is not None:
      log_str.write('messages_sent_dropped = ')
      log_str.write(str(self.messages_sent_dropped))
      log_str.write('  ')
    if self.bytes_sent_dropped is not None:
      log_str.write('bytes_sent_dropped = ')
      log_str.write(str(self.bytes_sent_dropped))
      log_str.write('  ')
    if self.messages_received_dropped is not None:
      log_str.write('messages_received_dropped = ')
      log_str.write(str(self.messages_received_dropped))
      log_str.write('  ')
    if self.bytes_received_dropped is not None:
      log_str.write('bytes_received_dropped = ')
      log_str.write(str(self.bytes_received_dropped))
      log_str.write('  ')
    if self.messages_sent_dropped_no_queue is not None:
      log_str.write('messages_sent_dropped_no_queue = ')
      log_str.write(str(self.messages_sent_dropped_no_queue))
      log_str.write('  ')
    if self.messages_sent_dropped_no_client is not None:
      log_str.write('messages_sent_dropped_no_client = ')
      log_str.write(str(self.messages_sent_dropped_no_client))
      log_str.write('  ')
    if self.messages_sent_dropped_no_session is not None:
      log_str.write('messages_sent_dropped_no_session = ')
      log_str.write(str(self.messages_sent_dropped_no_session))
      log_str.write('  ')
    if self.messages_sent_dropped_queue_level is not None:
      log_str.write('messages_sent_dropped_queue_level = ')
      log_str.write(str(self.messages_sent_dropped_queue_level))
      log_str.write('  ')
    if self.messages_sent_dropped_client_send_failed is not None:
      log_str.write('messages_sent_dropped_client_send_failed = ')
      log_str.write(str(self.messages_sent_dropped_client_send_failed))
      log_str.write('  ')
    if self.messages_sent_dropped_session_not_connected is not None:
      log_str.write('messages_sent_dropped_session_not_connected = ')
      log_str.write(str(self.messages_sent_dropped_session_not_connected))
      log_str.write('  ')
    if self.messages_sent_dropped_header_write_failed is not None:
      log_str.write('messages_sent_dropped_header_write_failed = ')
      log_str.write(str(self.messages_sent_dropped_header_write_failed))
      log_str.write('  ')
    if self.messages_sent_dropped_write_failed is not None:
      log_str.write('messages_sent_dropped_write_failed = ')
      log_str.write(str(self.messages_sent_dropped_write_failed))
      log_str.write('  ')
    if self.messages_sent_dropped_wrong_client_sm_state is not None:
      log_str.write('messages_sent_dropped_wrong_client_sm_state = ')
      log_str.write(str(self.messages_sent_dropped_wrong_client_sm_state))
      log_str.write('  ')
    if self.messages_sent_dropped_validation_failed is not None:
      log_str.write('messages_sent_dropped_validation_failed = ')
      log_str.write(str(self.messages_sent_dropped_validation_failed))
      log_str.write('  ')
    if self.messages_sent_dropped_rate_limited is not None:
      log_str.write('messages_sent_dropped_rate_limited = ')
      log_str.write(str(self.messages_sent_dropped_rate_limited))
      log_str.write('  ')
    if self.messages_sent_dropped_sending_disabled is not None:
      log_str.write('messages_sent_dropped_sending_disabled = ')
      log_str.write(str(self.messages_sent_dropped_sending_disabled))
      log_str.write('  ')
    if self.messages_sent_dropped_sending_to_syslog is not None:
      log_str.write('messages_sent_dropped_sending_to_syslog = ')
      log_str.write(str(self.messages_sent_dropped_sending_to_syslog))
      log_str.write('  ')
    if self.bytes_sent_dropped_no_queue is not None:
      log_str.write('bytes_sent_dropped_no_queue = ')
      log_str.write(str(self.bytes_sent_dropped_no_queue))
      log_str.write('  ')
    if self.bytes_sent_dropped_no_client is not None:
      log_str.write('bytes_sent_dropped_no_client = ')
      log_str.write(str(self.bytes_sent_dropped_no_client))
      log_str.write('  ')
    if self.bytes_sent_dropped_no_session is not None:
      log_str.write('bytes_sent_dropped_no_session = ')
      log_str.write(str(self.bytes_sent_dropped_no_session))
      log_str.write('  ')
    if self.bytes_sent_dropped_queue_level is not None:
      log_str.write('bytes_sent_dropped_queue_level = ')
      log_str.write(str(self.bytes_sent_dropped_queue_level))
      log_str.write('  ')
    if self.bytes_sent_dropped_client_send_failed is not None:
      log_str.write('bytes_sent_dropped_client_send_failed = ')
      log_str.write(str(self.bytes_sent_dropped_client_send_failed))
      log_str.write('  ')
    if self.bytes_sent_dropped_session_not_connected is not None:
      log_str.write('bytes_sent_dropped_session_not_connected = ')
      log_str.write(str(self.bytes_sent_dropped_session_not_connected))
      log_str.write('  ')
    if self.bytes_sent_dropped_header_write_failed is not None:
      log_str.write('bytes_sent_dropped_header_write_failed = ')
      log_str.write(str(self.bytes_sent_dropped_header_write_failed))
      log_str.write('  ')
    if self.bytes_sent_dropped_write_failed is not None:
      log_str.write('bytes_sent_dropped_write_failed = ')
      log_str.write(str(self.bytes_sent_dropped_write_failed))
      log_str.write('  ')
    if self.bytes_sent_dropped_wrong_client_sm_state is not None:
      log_str.write('bytes_sent_dropped_wrong_client_sm_state = ')
      log_str.write(str(self.bytes_sent_dropped_wrong_client_sm_state))
      log_str.write('  ')
    if self.bytes_sent_dropped_validation_failed is not None:
      log_str.write('bytes_sent_dropped_validation_failed = ')
      log_str.write(str(self.bytes_sent_dropped_validation_failed))
      log_str.write('  ')
    if self.bytes_sent_dropped_rate_limited is not None:
      log_str.write('bytes_sent_dropped_rate_limited = ')
      log_str.write(str(self.bytes_sent_dropped_rate_limited))
      log_str.write('  ')
    if self.bytes_sent_dropped_sending_disabled is not None:
      log_str.write('bytes_sent_dropped_sending_disabled = ')
      log_str.write(str(self.bytes_sent_dropped_sending_disabled))
      log_str.write('  ')
    if self.bytes_sent_dropped_sending_to_syslog is not None:
      log_str.write('bytes_sent_dropped_sending_to_syslog = ')
      log_str.write(str(self.bytes_sent_dropped_sending_to_syslog))
      log_str.write('  ')
    if self.messages_received_dropped_no_queue is not None:
      log_str.write('messages_received_dropped_no_queue = ')
      log_str.write(str(self.messages_received_dropped_no_queue))
      log_str.write('  ')
    if self.messages_received_dropped_queue_level is not None:
      log_str.write('messages_received_dropped_queue_level = ')
      log_str.write(str(self.messages_received_dropped_queue_level))
      log_str.write('  ')
    if self.messages_received_dropped_create_failed is not None:
      log_str.write('messages_received_dropped_create_failed = ')
      log_str.write(str(self.messages_received_dropped_create_failed))
      log_str.write('  ')
    if self.messages_received_dropped_control_msg_failed is not None:
      log_str.write('messages_received_dropped_control_msg_failed = ')
      log_str.write(str(self.messages_received_dropped_control_msg_failed))
      log_str.write('  ')
    if self.messages_received_dropped_decoding_failed is not None:
      log_str.write('messages_received_dropped_decoding_failed = ')
      log_str.write(str(self.messages_received_dropped_decoding_failed))
      log_str.write('  ')
    if self.bytes_received_dropped_no_queue is not None:
      log_str.write('bytes_received_dropped_no_queue = ')
      log_str.write(str(self.bytes_received_dropped_no_queue))
      log_str.write('  ')
    if self.bytes_received_dropped_queue_level is not None:
      log_str.write('bytes_received_dropped_queue_level = ')
      log_str.write(str(self.bytes_received_dropped_queue_level))
      log_str.write('  ')
    if self.bytes_received_dropped_create_failed is not None:
      log_str.write('bytes_received_dropped_create_failed = ')
      log_str.write(str(self.bytes_received_dropped_create_failed))
      log_str.write('  ')
    if self.bytes_received_dropped_control_msg_failed is not None:
      log_str.write('bytes_received_dropped_control_msg_failed = ')
      log_str.write(str(self.bytes_received_dropped_control_msg_failed))
      log_str.write('  ')
    if self.bytes_received_dropped_decoding_failed is not None:
      log_str.write('bytes_received_dropped_decoding_failed = ')
      log_str.write(str(self.bytes_received_dropped_decoding_failed))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.messages_sent is not None:
      size += getsizeof(self.messages_sent)
    if self.bytes_sent is not None:
      size += getsizeof(self.bytes_sent)
    if self.messages_received is not None:
      size += getsizeof(self.messages_received)
    if self.bytes_received is not None:
      size += getsizeof(self.bytes_received)
    if self.messages_sent_dropped is not None:
      size += getsizeof(self.messages_sent_dropped)
    if self.bytes_sent_dropped is not None:
      size += getsizeof(self.bytes_sent_dropped)
    if self.messages_received_dropped is not None:
      size += getsizeof(self.messages_received_dropped)
    if self.bytes_received_dropped is not None:
      size += getsizeof(self.bytes_received_dropped)
    if self.messages_sent_dropped_no_queue is not None:
      size += getsizeof(self.messages_sent_dropped_no_queue)
    if self.messages_sent_dropped_no_client is not None:
      size += getsizeof(self.messages_sent_dropped_no_client)
    if self.messages_sent_dropped_no_session is not None:
      size += getsizeof(self.messages_sent_dropped_no_session)
    if self.messages_sent_dropped_queue_level is not None:
      size += getsizeof(self.messages_sent_dropped_queue_level)
    if self.messages_sent_dropped_client_send_failed is not None:
      size += getsizeof(self.messages_sent_dropped_client_send_failed)
    if self.messages_sent_dropped_session_not_connected is not None:
      size += getsizeof(self.messages_sent_dropped_session_not_connected)
    if self.messages_sent_dropped_header_write_failed is not None:
      size += getsizeof(self.messages_sent_dropped_header_write_failed)
    if self.messages_sent_dropped_write_failed is not None:
      size += getsizeof(self.messages_sent_dropped_write_failed)
    if self.messages_sent_dropped_wrong_client_sm_state is not None:
      size += getsizeof(self.messages_sent_dropped_wrong_client_sm_state)
    if self.messages_sent_dropped_validation_failed is not None:
      size += getsizeof(self.messages_sent_dropped_validation_failed)
    if self.messages_sent_dropped_rate_limited is not None:
      size += getsizeof(self.messages_sent_dropped_rate_limited)
    if self.messages_sent_dropped_sending_disabled is not None:
      size += getsizeof(self.messages_sent_dropped_sending_disabled)
    if self.messages_sent_dropped_sending_to_syslog is not None:
      size += getsizeof(self.messages_sent_dropped_sending_to_syslog)
    if self.bytes_sent_dropped_no_queue is not None:
      size += getsizeof(self.bytes_sent_dropped_no_queue)
    if self.bytes_sent_dropped_no_client is not None:
      size += getsizeof(self.bytes_sent_dropped_no_client)
    if self.bytes_sent_dropped_no_session is not None:
      size += getsizeof(self.bytes_sent_dropped_no_session)
    if self.bytes_sent_dropped_queue_level is not None:
      size += getsizeof(self.bytes_sent_dropped_queue_level)
    if self.bytes_sent_dropped_client_send_failed is not None:
      size += getsizeof(self.bytes_sent_dropped_client_send_failed)
    if self.bytes_sent_dropped_session_not_connected is not None:
      size += getsizeof(self.bytes_sent_dropped_session_not_connected)
    if self.bytes_sent_dropped_header_write_failed is not None:
      size += getsizeof(self.bytes_sent_dropped_header_write_failed)
    if self.bytes_sent_dropped_write_failed is not None:
      size += getsizeof(self.bytes_sent_dropped_write_failed)
    if self.bytes_sent_dropped_wrong_client_sm_state is not None:
      size += getsizeof(self.bytes_sent_dropped_wrong_client_sm_state)
    if self.bytes_sent_dropped_validation_failed is not None:
      size += getsizeof(self.bytes_sent_dropped_validation_failed)
    if self.bytes_sent_dropped_rate_limited is not None:
      size += getsizeof(self.bytes_sent_dropped_rate_limited)
    if self.bytes_sent_dropped_sending_disabled is not None:
      size += getsizeof(self.bytes_sent_dropped_sending_disabled)
    if self.bytes_sent_dropped_sending_to_syslog is not None:
      size += getsizeof(self.bytes_sent_dropped_sending_to_syslog)
    if self.messages_received_dropped_no_queue is not None:
      size += getsizeof(self.messages_received_dropped_no_queue)
    if self.messages_received_dropped_queue_level is not None:
      size += getsizeof(self.messages_received_dropped_queue_level)
    if self.messages_received_dropped_create_failed is not None:
      size += getsizeof(self.messages_received_dropped_create_failed)
    if self.messages_received_dropped_control_msg_failed is not None:
      size += getsizeof(self.messages_received_dropped_control_msg_failed)
    if self.messages_received_dropped_decoding_failed is not None:
      size += getsizeof(self.messages_received_dropped_decoding_failed)
    if self.bytes_received_dropped_no_queue is not None:
      size += getsizeof(self.bytes_received_dropped_no_queue)
    if self.bytes_received_dropped_queue_level is not None:
      size += getsizeof(self.bytes_received_dropped_queue_level)
    if self.bytes_received_dropped_create_failed is not None:
      size += getsizeof(self.bytes_received_dropped_create_failed)
    if self.bytes_received_dropped_control_msg_failed is not None:
      size += getsizeof(self.bytes_received_dropped_control_msg_failed)
    if self.bytes_received_dropped_decoding_failed is not None:
      size += getsizeof(self.bytes_received_dropped_decoding_failed)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshMessageBasicStats(object):
  """
  Attributes:
   - messages_sent
   - bytes_sent
   - messages_received
   - bytes_received
   - messages_sent_dropped
   - messages_received_dropped
  """

  thrift_spec = (
    None, # 0
    (1, TType.U64, 'messages_sent', None, None, ), # 1
    (2, TType.U64, 'bytes_sent', None, None, ), # 2
    (3, TType.U64, 'messages_received', None, None, ), # 3
    (4, TType.U64, 'bytes_received', None, None, ), # 4
    (5, TType.U64, 'messages_sent_dropped', None, None, ), # 5
    (6, TType.U64, 'messages_received_dropped', None, None, ), # 6
  )

  def __init__(self, messages_sent=None, bytes_sent=None, messages_received=None, bytes_received=None, messages_sent_dropped=None, messages_received_dropped=None,):
    self.messages_sent = messages_sent
    self.bytes_sent = bytes_sent
    self.messages_received = messages_received
    self.bytes_received = bytes_received
    self.messages_sent_dropped = messages_sent_dropped
    self.messages_received_dropped = messages_received_dropped

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U64:
          (length, self.messages_sent) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U64:
          (length, self.bytes_sent) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U64:
          (length, self.messages_received) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U64:
          (length, self.bytes_received) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U64:
          (length, self.messages_sent_dropped) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.U64:
          (length, self.messages_received_dropped) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.messages_sent is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent', TType.U64, 1, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_sent is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_sent', TType.U64, 2, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_sent) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_received is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_received', TType.U64, 3, annotations) < 0: return -1
      if oprot.writeU64(self.messages_received) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.bytes_received is not None:
      annotations = {}
      if oprot.writeFieldBegin('bytes_received', TType.U64, 4, annotations) < 0: return -1
      if oprot.writeU64(self.bytes_received) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_sent_dropped is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_sent_dropped', TType.U64, 5, annotations) < 0: return -1
      if oprot.writeU64(self.messages_sent_dropped) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.messages_received_dropped is not None:
      annotations = {}
      if oprot.writeFieldBegin('messages_received_dropped', TType.U64, 6, annotations) < 0: return -1
      if oprot.writeU64(self.messages_received_dropped) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.messages_sent is not None:
      log_str.write('messages_sent = ')
      log_str.write(str(self.messages_sent))
      log_str.write('  ')
    if self.bytes_sent is not None:
      log_str.write('bytes_sent = ')
      log_str.write(str(self.bytes_sent))
      log_str.write('  ')
    if self.messages_received is not None:
      log_str.write('messages_received = ')
      log_str.write(str(self.messages_received))
      log_str.write('  ')
    if self.bytes_received is not None:
      log_str.write('bytes_received = ')
      log_str.write(str(self.bytes_received))
      log_str.write('  ')
    if self.messages_sent_dropped is not None:
      log_str.write('messages_sent_dropped = ')
      log_str.write(str(self.messages_sent_dropped))
      log_str.write('  ')
    if self.messages_received_dropped is not None:
      log_str.write('messages_received_dropped = ')
      log_str.write(str(self.messages_received_dropped))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.messages_sent is not None:
      size += getsizeof(self.messages_sent)
    if self.bytes_sent is not None:
      size += getsizeof(self.bytes_sent)
    if self.messages_received is not None:
      size += getsizeof(self.messages_received)
    if self.bytes_received is not None:
      size += getsizeof(self.bytes_received)
    if self.messages_sent_dropped is not None:
      size += getsizeof(self.messages_sent_dropped)
    if self.messages_received_dropped is not None:
      size += getsizeof(self.messages_received_dropped)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshMessageTypeBasicStats(object):
  """
  Attributes:
   - message_type
   - stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message_type', None, None, ), # 1
    (2, TType.STRUCT, 'stats', (SandeshMessageBasicStats, SandeshMessageBasicStats.thrift_spec), None, ), # 2
  )

  def __init__(self, message_type=None, stats=None,):
    self.message_type = message_type
    self.stats = stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.message_type) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.stats = SandeshMessageBasicStats()
          read_cnt += self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.message_type is not None:
      annotations = {}
      if oprot.writeFieldBegin('message_type', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.message_type) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('stats', TType.STRUCT, 2, annotations) < 0: return -1
      if self.stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.message_type is not None:
      log_str.write('message_type = ')
      log_str.write(self.message_type)
      log_str.write('  ')
    if self.stats is not None:
      log_str.write('stats = ')
      log_str.write('<<  ')
      log_str.write(self.stats.log())
      log_str.write('>>')
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.message_type is not None:
      size += getsizeof(self.message_type)
    if self.stats is not None:
      size += getsizeof(self.stats)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshMessageTypeStats(object):
  """
  Attributes:
   - message_type
   - stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message_type', None, None, ), # 1
    (2, TType.STRUCT, 'stats', (SandeshMessageStats, SandeshMessageStats.thrift_spec), None, ), # 2
  )

  def __init__(self, message_type=None, stats=None,):
    self.message_type = message_type
    self.stats = stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.message_type) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.stats = SandeshMessageStats()
          read_cnt += self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.message_type is not None:
      annotations = {}
      if oprot.writeFieldBegin('message_type', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.message_type) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('stats', TType.STRUCT, 2, annotations) < 0: return -1
      if self.stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.message_type is not None:
      log_str.write('message_type = ')
      log_str.write(self.message_type)
      log_str.write('  ')
    if self.stats is not None:
      log_str.write('stats = ')
      log_str.write('<<  ')
      log_str.write(self.stats.log())
      log_str.write('>>')
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.message_type is not None:
      size += getsizeof(self.message_type)
    if self.stats is not None:
      size += getsizeof(self.stats)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshQueueStats(object):
  """
  Attributes:
   - enqueues
   - count
   - max_count
  """

  thrift_spec = (
    None, # 0
    (1, TType.U64, 'enqueues', None, None, ), # 1
    (2, TType.U64, 'count', None, None, ), # 2
    (3, TType.U64, 'max_count', None, None, ), # 3
  )

  def __init__(self, enqueues=None, count=None, max_count=None,):
    self.enqueues = enqueues
    self.count = count
    self.max_count = max_count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U64:
          (length, self.enqueues) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U64:
          (length, self.count) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U64:
          (length, self.max_count) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.enqueues is not None:
      annotations = {}
      if oprot.writeFieldBegin('enqueues', TType.U64, 1, annotations) < 0: return -1
      if oprot.writeU64(self.enqueues) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.count is not None:
      annotations = {}
      if oprot.writeFieldBegin('count', TType.U64, 2, annotations) < 0: return -1
      if oprot.writeU64(self.count) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.max_count is not None:
      annotations = {}
      if oprot.writeFieldBegin('max_count', TType.U64, 3, annotations) < 0: return -1
      if oprot.writeU64(self.max_count) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.enqueues is not None:
      log_str.write('enqueues = ')
      log_str.write(str(self.enqueues))
      log_str.write('  ')
    if self.count is not None:
      log_str.write('count = ')
      log_str.write(str(self.count))
      log_str.write('  ')
    if self.max_count is not None:
      log_str.write('max_count = ')
      log_str.write(str(self.max_count))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.enqueues is not None:
      size += getsizeof(self.enqueues)
    if self.count is not None:
      size += getsizeof(self.count)
    if self.max_count is not None:
      size += getsizeof(self.max_count)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshGeneratorStats(object):
  """
  Attributes:
   - type_stats
   - aggregate_stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'type_stats', (TType.STRUCT,(SandeshMessageTypeStats, SandeshMessageTypeStats.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'aggregate_stats', (SandeshMessageStats, SandeshMessageStats.thrift_spec), None, ), # 2
  )

  def __init__(self, type_stats=None, aggregate_stats=None,):
    self.type_stats = type_stats
    self.aggregate_stats = aggregate_stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.type_stats = []
          (length, _etype3, _size0) = iprot.readListBegin()
          read_cnt += length
          for _i4 in xrange(_size0):
            _elem5 = SandeshMessageTypeStats()
            read_cnt += _elem5.read(iprot)
            self.type_stats.append(_elem5)
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.aggregate_stats = SandeshMessageStats()
          read_cnt += self.aggregate_stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.type_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('type_stats', TType.LIST, 1, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRUCT, len(self.type_stats)) < 0: return -1
      for iter6 in self.type_stats:
        if iter6.write(oprot) < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.aggregate_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('aggregate_stats', TType.STRUCT, 2, annotations) < 0: return -1
      if self.aggregate_stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.type_stats is not None:
      log_str.write('type_stats = ')
      log_str.write('[ ')
      for iter7 in self.type_stats:
        log_str.write('<<  ')
        log_str.write(iter7.log())
        log_str.write('>>')
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.aggregate_stats is not None:
      log_str.write('aggregate_stats = ')
      log_str.write('<<  ')
      log_str.write(self.aggregate_stats.log())
      log_str.write('>>')
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.type_stats is not None:
      size += getsizeof(self.type_stats)
      size += sum(map(getsizeof, self.type_stats))
    if self.aggregate_stats is not None:
      size += getsizeof(self.aggregate_stats)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshGeneratorBasicStats(object):
  """
  Attributes:
   - type_stats
   - aggregate_stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'type_stats', (TType.STRUCT,(SandeshMessageTypeBasicStats, SandeshMessageTypeBasicStats.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'aggregate_stats', (SandeshMessageBasicStats, SandeshMessageBasicStats.thrift_spec), None, ), # 2
  )

  def __init__(self, type_stats=None, aggregate_stats=None,):
    self.type_stats = type_stats
    self.aggregate_stats = aggregate_stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.type_stats = []
          (length, _etype11, _size8) = iprot.readListBegin()
          read_cnt += length
          for _i12 in xrange(_size8):
            _elem13 = SandeshMessageTypeBasicStats()
            read_cnt += _elem13.read(iprot)
            self.type_stats.append(_elem13)
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.aggregate_stats = SandeshMessageBasicStats()
          read_cnt += self.aggregate_stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.type_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('type_stats', TType.LIST, 1, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRUCT, len(self.type_stats)) < 0: return -1
      for iter14 in self.type_stats:
        if iter14.write(oprot) < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.aggregate_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('aggregate_stats', TType.STRUCT, 2, annotations) < 0: return -1
      if self.aggregate_stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.type_stats is not None:
      log_str.write('type_stats = ')
      log_str.write('[ ')
      for iter15 in self.type_stats:
        log_str.write('<<  ')
        log_str.write(iter15.log())
        log_str.write('>>')
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.aggregate_stats is not None:
      log_str.write('aggregate_stats = ')
      log_str.write('<<  ')
      log_str.write(self.aggregate_stats.log())
      log_str.write('>>')
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.type_stats is not None:
      size += getsizeof(self.type_stats)
      size += sum(map(getsizeof, self.type_stats))
    if self.aggregate_stats is not None:
      size += getsizeof(self.aggregate_stats)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSendQueueParams(object):
  """
  Attributes:
   - high
   - queue_count
   - sending_level
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'high', None, None, ), # 1
    (2, TType.U32, 'queue_count', None, None, ), # 2
    (3, TType.STRING, 'sending_level', None, None, ), # 3
  )

  def __init__(self, high=None, queue_count=None, sending_level=None,):
    self.high = high
    self.queue_count = queue_count
    self.sending_level = sending_level

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          (length, self.high) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U32:
          (length, self.queue_count) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.sending_level) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.high is not None:
      annotations = {}
      if oprot.writeFieldBegin('high', TType.BOOL, 1, annotations) < 0: return -1
      if oprot.writeBool(self.high) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.queue_count is not None:
      annotations = {}
      if oprot.writeFieldBegin('queue_count', TType.U32, 2, annotations) < 0: return -1
      if oprot.writeU32(self.queue_count) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.sending_level is not None:
      annotations = {}
      if oprot.writeFieldBegin('sending_level', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.sending_level) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.high is not None:
      log_str.write('high = ')
      if self.high:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.queue_count is not None:
      log_str.write('queue_count = ')
      log_str.write(str(self.queue_count))
      log_str.write('  ')
    if self.sending_level is not None:
      log_str.write('sending_level = ')
      log_str.write(self.sending_level)
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.high is not None:
      size += getsizeof(self.high)
    if self.queue_count is not None:
      size += getsizeof(self.queue_count)
    if self.sending_level is not None:
      size += getsizeof(self.sending_level)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshUVETypeInfo(object):
  """
  Attributes:
   - type_name
   - seq_num
   - period
   - dsconf
   - timeout
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'type_name', None, None, ), # 1
    (2, TType.U32, 'seq_num', None, None, ), # 2
    (3, TType.I32, 'period', None, None, ), # 3
    (4, TType.MAP, 'dsconf', (TType.STRING,None,TType.STRING,None), None, ), # 4
    (5, TType.I32, 'timeout', None, None, ), # 5
  )

  def __init__(self, type_name=None, seq_num=None, period=None, dsconf=None, timeout=None,):
    self.type_name = type_name
    self.seq_num = seq_num
    self.period = period
    self.dsconf = dsconf
    self.timeout = timeout

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.type_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U32:
          (length, self.seq_num) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          (length, self.period) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.dsconf = {}
          (length, _ktype17, _vtype18, _size16 ) = iprot.readMapBegin() 
          read_cnt += length
          for _i20 in xrange(_size16):
            read_cnt += iprot.readContainerElementBegin()
            (length, _key21) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            read_cnt += iprot.readContainerElementBegin()
            (length, _val22) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            self.dsconf[_key21] = _val22
          read_cnt += iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          (length, self.timeout) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.type_name is not None:
      annotations = {}
      annotations['link'] = 'SandeshUVECacheReq'
      if oprot.writeFieldBegin('type_name', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.type_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.seq_num is not None:
      annotations = {}
      if oprot.writeFieldBegin('seq_num', TType.U32, 2, annotations) < 0: return -1
      if oprot.writeU32(self.seq_num) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.period is not None:
      annotations = {}
      if oprot.writeFieldBegin('period', TType.I32, 3, annotations) < 0: return -1
      if oprot.writeI32(self.period) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.dsconf is not None:
      annotations = {}
      if oprot.writeFieldBegin('dsconf', TType.MAP, 4, annotations) < 0: return -1
      if oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.dsconf)) < 0: return -1
      for kiter23,viter24 in self.dsconf.iteritems():
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(kiter23) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(viter24) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeMapEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.timeout is not None:
      annotations = {}
      if oprot.writeFieldBegin('timeout', TType.I32, 5, annotations) < 0: return -1
      if oprot.writeI32(self.timeout) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.type_name is not None:
      log_str.write('type_name = ')
      log_str.write(self.type_name)
      log_str.write('  ')
    if self.seq_num is not None:
      log_str.write('seq_num = ')
      log_str.write(str(self.seq_num))
      log_str.write('  ')
    if self.period is not None:
      log_str.write('period = ')
      log_str.write(str(self.period))
      log_str.write('  ')
    if self.dsconf is not None:
      log_str.write('dsconf = ')
      log_str.write('{ ')
      for kiter25,viter26 in self.dsconf.iteritems():
        log_str.write(kiter25)
        log_str.write(' : ')
        log_str.write(viter26)
      log_str.write(' }')
      log_str.write('  ')
    if self.timeout is not None:
      log_str.write('timeout = ')
      log_str.write(str(self.timeout))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.type_name is not None:
      size += getsizeof(self.type_name)
    if self.seq_num is not None:
      size += getsizeof(self.seq_num)
    if self.period is not None:
      size += getsizeof(self.period)
    if self.dsconf is not None:
      size += getsizeof(self.dsconf)
      size += sum(map(getsizeof, chain.from_iterable(self.dsconf.iteritems())))
    if self.timeout is not None:
      size += getsizeof(self.timeout)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshStateMachineEvStats(object):
  """
  Attributes:
   - event
   - enqueues
   - dequeues
   - enqueue_fails
   - dequeue_fails
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'event', None, None, ), # 1
    (2, TType.U64, 'enqueues', None, None, ), # 2
    (3, TType.U64, 'dequeues', None, None, ), # 3
    (4, TType.U64, 'enqueue_fails', None, None, ), # 4
    (5, TType.U64, 'dequeue_fails', None, None, ), # 5
  )

  def __init__(self, event=None, enqueues=None, dequeues=None, enqueue_fails=None, dequeue_fails=None,):
    self.event = event
    self.enqueues = enqueues
    self.dequeues = dequeues
    self.enqueue_fails = enqueue_fails
    self.dequeue_fails = dequeue_fails

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.event) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U64:
          (length, self.enqueues) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U64:
          (length, self.dequeues) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U64:
          (length, self.enqueue_fails) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U64:
          (length, self.dequeue_fails) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.event is not None:
      annotations = {}
      if oprot.writeFieldBegin('event', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.event) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.enqueues is not None:
      annotations = {}
      if oprot.writeFieldBegin('enqueues', TType.U64, 2, annotations) < 0: return -1
      if oprot.writeU64(self.enqueues) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.dequeues is not None:
      annotations = {}
      if oprot.writeFieldBegin('dequeues', TType.U64, 3, annotations) < 0: return -1
      if oprot.writeU64(self.dequeues) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.enqueue_fails is not None:
      annotations = {}
      if oprot.writeFieldBegin('enqueue_fails', TType.U64, 4, annotations) < 0: return -1
      if oprot.writeU64(self.enqueue_fails) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.dequeue_fails is not None:
      annotations = {}
      if oprot.writeFieldBegin('dequeue_fails', TType.U64, 5, annotations) < 0: return -1
      if oprot.writeU64(self.dequeue_fails) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.event is not None:
      log_str.write('event = ')
      log_str.write(self.event)
      log_str.write('  ')
    if self.enqueues is not None:
      log_str.write('enqueues = ')
      log_str.write(str(self.enqueues))
      log_str.write('  ')
    if self.dequeues is not None:
      log_str.write('dequeues = ')
      log_str.write(str(self.dequeues))
      log_str.write('  ')
    if self.enqueue_fails is not None:
      log_str.write('enqueue_fails = ')
      log_str.write(str(self.enqueue_fails))
      log_str.write('  ')
    if self.dequeue_fails is not None:
      log_str.write('dequeue_fails = ')
      log_str.write(str(self.dequeue_fails))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.event is not None:
      size += getsizeof(self.event)
    if self.enqueues is not None:
      size += getsizeof(self.enqueues)
    if self.dequeues is not None:
      size += getsizeof(self.dequeues)
    if self.enqueue_fails is not None:
      size += getsizeof(self.enqueue_fails)
    if self.dequeue_fails is not None:
      size += getsizeof(self.dequeue_fails)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshStateMachineStats(object):
  """
  Attributes:
   - ev_stats
   - state
   - state_since
   - last_state
   - last_event
   - last_event_at
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'ev_stats', (TType.STRUCT,(SandeshStateMachineEvStats, SandeshStateMachineEvStats.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'state', None, None, ), # 2
    (3, TType.U64, 'state_since', None, None, ), # 3
    (4, TType.STRING, 'last_state', None, None, ), # 4
    (5, TType.STRING, 'last_event', None, None, ), # 5
    (6, TType.U64, 'last_event_at', None, None, ), # 6
  )

  def __init__(self, ev_stats=None, state=None, state_since=None, last_state=None, last_event=None, last_event_at=None,):
    self.ev_stats = ev_stats
    self.state = state
    self.state_since = state_since
    self.last_state = last_state
    self.last_event = last_event
    self.last_event_at = last_event_at

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.ev_stats = []
          (length, _etype30, _size27) = iprot.readListBegin()
          read_cnt += length
          for _i31 in xrange(_size27):
            _elem32 = SandeshStateMachineEvStats()
            read_cnt += _elem32.read(iprot)
            self.ev_stats.append(_elem32)
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.state) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U64:
          (length, self.state_since) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          (length, self.last_state) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          (length, self.last_event) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.U64:
          (length, self.last_event_at) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.ev_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('ev_stats', TType.LIST, 1, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRUCT, len(self.ev_stats)) < 0: return -1
      for iter33 in self.ev_stats:
        if iter33.write(oprot) < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.state is not None:
      annotations = {}
      if oprot.writeFieldBegin('state', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.state) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.state_since is not None:
      annotations = {}
      if oprot.writeFieldBegin('state_since', TType.U64, 3, annotations) < 0: return -1
      if oprot.writeU64(self.state_since) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.last_state is not None:
      annotations = {}
      if oprot.writeFieldBegin('last_state', TType.STRING, 4, annotations) < 0: return -1
      if oprot.writeString(self.last_state) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.last_event is not None:
      annotations = {}
      if oprot.writeFieldBegin('last_event', TType.STRING, 5, annotations) < 0: return -1
      if oprot.writeString(self.last_event) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.last_event_at is not None:
      annotations = {}
      if oprot.writeFieldBegin('last_event_at', TType.U64, 6, annotations) < 0: return -1
      if oprot.writeU64(self.last_event_at) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.ev_stats is not None:
      log_str.write('ev_stats = ')
      log_str.write('[ ')
      for iter34 in self.ev_stats:
        log_str.write('<<  ')
        log_str.write(iter34.log())
        log_str.write('>>')
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.state is not None:
      log_str.write('state = ')
      log_str.write(self.state)
      log_str.write('  ')
    if self.state_since is not None:
      log_str.write('state_since = ')
      log_str.write(str(self.state_since))
      log_str.write('  ')
    if self.last_state is not None:
      log_str.write('last_state = ')
      log_str.write(self.last_state)
      log_str.write('  ')
    if self.last_event is not None:
      log_str.write('last_event = ')
      log_str.write(self.last_event)
      log_str.write('  ')
    if self.last_event_at is not None:
      log_str.write('last_event_at = ')
      log_str.write(str(self.last_event_at))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.ev_stats is not None:
      size += getsizeof(self.ev_stats)
      size += sum(map(getsizeof, self.ev_stats))
    if self.state is not None:
      size += getsizeof(self.state)
    if self.state_since is not None:
      size += getsizeof(self.state_since)
    if self.last_state is not None:
      size += getsizeof(self.last_state)
    if self.last_event is not None:
      size += getsizeof(self.last_event)
    if self.last_event_at is not None:
      size += getsizeof(self.last_event_at)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshClientInfo(object):
  """
  Attributes:
   - status
   - successful_connections
   - pid
   - http_port
   - start_time
   - collector_name
   - collector_ip
   - collector_list
   - rx_socket_stats
   - tx_socket_stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'status', None, None, ), # 1
    (2, TType.U32, 'successful_connections', None, None, ), # 2
    (3, TType.U32, 'pid', None, None, ), # 3
    (4, TType.U32, 'http_port', None, None, ), # 4
    (5, TType.U64, 'start_time', None, None, ), # 5
    (6, TType.STRING, 'collector_name', None, None, ), # 6
    None, # 7
    None, # 8
    (9, TType.STRUCT, 'rx_socket_stats', (io.ttypes.SocketIOStats, io.ttypes.SocketIOStats.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'tx_socket_stats', (io.ttypes.SocketIOStats, io.ttypes.SocketIOStats.thrift_spec), None, ), # 10
    (11, TType.STRING, 'collector_ip', None, None, ), # 11
    (12, TType.LIST, 'collector_list', (TType.STRING,None), None, ), # 12
  )

  def __init__(self, status=None, successful_connections=None, pid=None, http_port=None, start_time=None, collector_name=None, collector_ip=None, collector_list=None, rx_socket_stats=None, tx_socket_stats=None,):
    self.status = status
    self.successful_connections = successful_connections
    self.pid = pid
    self.http_port = http_port
    self.start_time = start_time
    self.collector_name = collector_name
    self.collector_ip = collector_ip
    self.collector_list = collector_list
    self.rx_socket_stats = rx_socket_stats
    self.tx_socket_stats = tx_socket_stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.status) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U32:
          (length, self.successful_connections) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U32:
          (length, self.pid) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U32:
          (length, self.http_port) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U64:
          (length, self.start_time) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          (length, self.collector_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          (length, self.collector_ip) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.collector_list = []
          (length, _etype38, _size35) = iprot.readListBegin()
          read_cnt += length
          for _i39 in xrange(_size35):
            read_cnt += iprot.readContainerElementBegin()
            (length, _elem40) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            self.collector_list.append(_elem40)
            read_cnt += iprot.readContainerElementEnd()
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.rx_socket_stats = io.ttypes.SocketIOStats()
          read_cnt += self.rx_socket_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.tx_socket_stats = io.ttypes.SocketIOStats()
          read_cnt += self.tx_socket_stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.status is not None:
      annotations = {}
      if oprot.writeFieldBegin('status', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.status) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.successful_connections is not None:
      annotations = {}
      if oprot.writeFieldBegin('successful_connections', TType.U32, 2, annotations) < 0: return -1
      if oprot.writeU32(self.successful_connections) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.pid is not None:
      annotations = {}
      if oprot.writeFieldBegin('pid', TType.U32, 3, annotations) < 0: return -1
      if oprot.writeU32(self.pid) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.http_port is not None:
      annotations = {}
      if oprot.writeFieldBegin('http_port', TType.U32, 4, annotations) < 0: return -1
      if oprot.writeU32(self.http_port) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.start_time is not None:
      annotations = {}
      if oprot.writeFieldBegin('start_time', TType.U64, 5, annotations) < 0: return -1
      if oprot.writeU64(self.start_time) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.collector_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('collector_name', TType.STRING, 6, annotations) < 0: return -1
      if oprot.writeString(self.collector_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.rx_socket_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('rx_socket_stats', TType.STRUCT, 9, annotations) < 0: return -1
      if self.rx_socket_stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.tx_socket_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('tx_socket_stats', TType.STRUCT, 10, annotations) < 0: return -1
      if self.tx_socket_stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.collector_ip is not None:
      annotations = {}
      if oprot.writeFieldBegin('collector_ip', TType.STRING, 11, annotations) < 0: return -1
      if oprot.writeString(self.collector_ip) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.collector_list is not None:
      annotations = {}
      if oprot.writeFieldBegin('collector_list', TType.LIST, 12, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRING, len(self.collector_list)) < 0: return -1
      for iter41 in self.collector_list:
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(iter41) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.status is not None:
      log_str.write('status = ')
      log_str.write(self.status)
      log_str.write('  ')
    if self.successful_connections is not None:
      log_str.write('successful_connections = ')
      log_str.write(str(self.successful_connections))
      log_str.write('  ')
    if self.pid is not None:
      log_str.write('pid = ')
      log_str.write(str(self.pid))
      log_str.write('  ')
    if self.http_port is not None:
      log_str.write('http_port = ')
      log_str.write(str(self.http_port))
      log_str.write('  ')
    if self.start_time is not None:
      log_str.write('start_time = ')
      log_str.write(str(self.start_time))
      log_str.write('  ')
    if self.collector_name is not None:
      log_str.write('collector_name = ')
      log_str.write(self.collector_name)
      log_str.write('  ')
    if self.collector_ip is not None:
      log_str.write('collector_ip = ')
      log_str.write(self.collector_ip)
      log_str.write('  ')
    if self.collector_list is not None:
      log_str.write('collector_list = ')
      log_str.write('[ ')
      for iter42 in self.collector_list:
        log_str.write(iter42)
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.rx_socket_stats is not None:
      log_str.write('rx_socket_stats = ')
      log_str.write('<<  ')
      log_str.write(self.rx_socket_stats.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.tx_socket_stats is not None:
      log_str.write('tx_socket_stats = ')
      log_str.write('<<  ')
      log_str.write(self.tx_socket_stats.log())
      log_str.write('>>')
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.status is not None:
      size += getsizeof(self.status)
    if self.successful_connections is not None:
      size += getsizeof(self.successful_connections)
    if self.pid is not None:
      size += getsizeof(self.pid)
    if self.http_port is not None:
      size += getsizeof(self.http_port)
    if self.start_time is not None:
      size += getsizeof(self.start_time)
    if self.collector_name is not None:
      size += getsizeof(self.collector_name)
    if self.collector_ip is not None:
      size += getsizeof(self.collector_ip)
    if self.collector_list is not None:
      size += getsizeof(self.collector_list)
      size += sum(map(getsizeof, self.collector_list))
    if self.rx_socket_stats is not None:
      size += getsizeof(self.rx_socket_stats)
    if self.tx_socket_stats is not None:
      size += getsizeof(self.tx_socket_stats)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSessionStats(object):
  """
  Attributes:
   - num_recv_msg
   - num_recv_msg_fail
   - num_recv_fail
   - num_send_msg
   - num_send_msg_fail
   - num_send_buffer_fail
   - num_wait_msgq_enqueue
   - num_wait_msgq_dequeue
   - num_write_ready_cb_error
  """

  thrift_spec = (
    None, # 0
    (1, TType.U64, 'num_recv_msg', None, None, ), # 1
    (2, TType.U64, 'num_recv_msg_fail', None, None, ), # 2
    (3, TType.U64, 'num_recv_fail', None, None, ), # 3
    (4, TType.U64, 'num_send_msg', None, None, ), # 4
    (5, TType.U64, 'num_send_msg_fail', None, None, ), # 5
    (6, TType.U64, 'num_send_buffer_fail', None, None, ), # 6
    (7, TType.U64, 'num_wait_msgq_enqueue', None, None, ), # 7
    (8, TType.U64, 'num_wait_msgq_dequeue', None, None, ), # 8
    (9, TType.U64, 'num_write_ready_cb_error', None, None, ), # 9
  )

  def __init__(self, num_recv_msg=None, num_recv_msg_fail=None, num_recv_fail=None, num_send_msg=None, num_send_msg_fail=None, num_send_buffer_fail=None, num_wait_msgq_enqueue=None, num_wait_msgq_dequeue=None, num_write_ready_cb_error=None,):
    self.num_recv_msg = num_recv_msg
    self.num_recv_msg_fail = num_recv_msg_fail
    self.num_recv_fail = num_recv_fail
    self.num_send_msg = num_send_msg
    self.num_send_msg_fail = num_send_msg_fail
    self.num_send_buffer_fail = num_send_buffer_fail
    self.num_wait_msgq_enqueue = num_wait_msgq_enqueue
    self.num_wait_msgq_dequeue = num_wait_msgq_dequeue
    self.num_write_ready_cb_error = num_write_ready_cb_error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U64:
          (length, self.num_recv_msg) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U64:
          (length, self.num_recv_msg_fail) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U64:
          (length, self.num_recv_fail) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U64:
          (length, self.num_send_msg) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U64:
          (length, self.num_send_msg_fail) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.U64:
          (length, self.num_send_buffer_fail) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.U64:
          (length, self.num_wait_msgq_enqueue) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.U64:
          (length, self.num_wait_msgq_dequeue) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.U64:
          (length, self.num_write_ready_cb_error) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.num_recv_msg is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_recv_msg', TType.U64, 1, annotations) < 0: return -1
      if oprot.writeU64(self.num_recv_msg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.num_recv_msg_fail is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_recv_msg_fail', TType.U64, 2, annotations) < 0: return -1
      if oprot.writeU64(self.num_recv_msg_fail) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.num_recv_fail is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_recv_fail', TType.U64, 3, annotations) < 0: return -1
      if oprot.writeU64(self.num_recv_fail) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.num_send_msg is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_send_msg', TType.U64, 4, annotations) < 0: return -1
      if oprot.writeU64(self.num_send_msg) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.num_send_msg_fail is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_send_msg_fail', TType.U64, 5, annotations) < 0: return -1
      if oprot.writeU64(self.num_send_msg_fail) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.num_send_buffer_fail is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_send_buffer_fail', TType.U64, 6, annotations) < 0: return -1
      if oprot.writeU64(self.num_send_buffer_fail) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.num_wait_msgq_enqueue is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_wait_msgq_enqueue', TType.U64, 7, annotations) < 0: return -1
      if oprot.writeU64(self.num_wait_msgq_enqueue) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.num_wait_msgq_dequeue is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_wait_msgq_dequeue', TType.U64, 8, annotations) < 0: return -1
      if oprot.writeU64(self.num_wait_msgq_dequeue) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.num_write_ready_cb_error is not None:
      annotations = {}
      if oprot.writeFieldBegin('num_write_ready_cb_error', TType.U64, 9, annotations) < 0: return -1
      if oprot.writeU64(self.num_write_ready_cb_error) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.num_recv_msg is not None:
      log_str.write('num_recv_msg = ')
      log_str.write(str(self.num_recv_msg))
      log_str.write('  ')
    if self.num_recv_msg_fail is not None:
      log_str.write('num_recv_msg_fail = ')
      log_str.write(str(self.num_recv_msg_fail))
      log_str.write('  ')
    if self.num_recv_fail is not None:
      log_str.write('num_recv_fail = ')
      log_str.write(str(self.num_recv_fail))
      log_str.write('  ')
    if self.num_send_msg is not None:
      log_str.write('num_send_msg = ')
      log_str.write(str(self.num_send_msg))
      log_str.write('  ')
    if self.num_send_msg_fail is not None:
      log_str.write('num_send_msg_fail = ')
      log_str.write(str(self.num_send_msg_fail))
      log_str.write('  ')
    if self.num_send_buffer_fail is not None:
      log_str.write('num_send_buffer_fail = ')
      log_str.write(str(self.num_send_buffer_fail))
      log_str.write('  ')
    if self.num_wait_msgq_enqueue is not None:
      log_str.write('num_wait_msgq_enqueue = ')
      log_str.write(str(self.num_wait_msgq_enqueue))
      log_str.write('  ')
    if self.num_wait_msgq_dequeue is not None:
      log_str.write('num_wait_msgq_dequeue = ')
      log_str.write(str(self.num_wait_msgq_dequeue))
      log_str.write('  ')
    if self.num_write_ready_cb_error is not None:
      log_str.write('num_write_ready_cb_error = ')
      log_str.write(str(self.num_write_ready_cb_error))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.num_recv_msg is not None:
      size += getsizeof(self.num_recv_msg)
    if self.num_recv_msg_fail is not None:
      size += getsizeof(self.num_recv_msg_fail)
    if self.num_recv_fail is not None:
      size += getsizeof(self.num_recv_fail)
    if self.num_send_msg is not None:
      size += getsizeof(self.num_send_msg)
    if self.num_send_msg_fail is not None:
      size += getsizeof(self.num_send_msg_fail)
    if self.num_send_buffer_fail is not None:
      size += getsizeof(self.num_send_buffer_fail)
    if self.num_wait_msgq_enqueue is not None:
      size += getsizeof(self.num_wait_msgq_enqueue)
    if self.num_wait_msgq_dequeue is not None:
      size += getsizeof(self.num_wait_msgq_dequeue)
    if self.num_write_ready_cb_error is not None:
      size += getsizeof(self.num_write_ready_cb_error)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ModuleClientState(object):
  """
  Attributes:
   - name
   - deleted
   - client_info
   - sm_queue_count
   - sm_stats
   - session_stats
   - session_rx_socket_stats
   - session_tx_socket_stats
   - msg_type_agg: @display_name:Sandesh Client Message Type Stats
   - tx_msg_agg: @display_name:Sandesh Client Message Stats
   - max_sm_queue_count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.BOOL, 'deleted', None, None, ), # 2
    (3, TType.STRUCT, 'client_info', (SandeshClientInfo, SandeshClientInfo.thrift_spec), None, ), # 3
    None, # 4
    (5, TType.U64, 'sm_queue_count', None, None, ), # 5
    (6, TType.STRUCT, 'sm_stats', (SandeshStateMachineStats, SandeshStateMachineStats.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'session_stats', (SandeshSessionStats, SandeshSessionStats.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'session_rx_socket_stats', (io.ttypes.SocketIOStats, io.ttypes.SocketIOStats.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'session_tx_socket_stats', (io.ttypes.SocketIOStats, io.ttypes.SocketIOStats.thrift_spec), None, ), # 9
    (10, TType.MAP, 'msg_type_agg', (TType.STRING,None,TType.STRUCT,(SandeshMessageStats, SandeshMessageStats.thrift_spec)), None, ), # 10
    None, # 11
    None, # 12
    None, # 13
    (14, TType.U64, 'max_sm_queue_count', None, None, ), # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    (20, TType.MAP, 'tx_msg_agg', (TType.STRING,None,TType.U64,None), None, ), # 20
  )

  def __init__(self, name=None, deleted=None, client_info=None, sm_queue_count=None, sm_stats=None, session_stats=None, session_rx_socket_stats=None, session_tx_socket_stats=None, msg_type_agg=None, tx_msg_agg=None, max_sm_queue_count=None,):
    self.name = name
    self.deleted = deleted
    self.client_info = client_info
    self.sm_queue_count = sm_queue_count
    self.sm_stats = sm_stats
    self.session_stats = session_stats
    self.session_rx_socket_stats = session_rx_socket_stats
    self.session_tx_socket_stats = session_tx_socket_stats
    self.msg_type_agg = msg_type_agg
    self.tx_msg_agg = tx_msg_agg
    self.max_sm_queue_count = max_sm_queue_count
    self._table = 'ObjectGeneratorInfo'

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          (length, self.deleted) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.client_info = SandeshClientInfo()
          read_cnt += self.client_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U64:
          (length, self.sm_queue_count) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.sm_stats = SandeshStateMachineStats()
          read_cnt += self.sm_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.session_stats = SandeshSessionStats()
          read_cnt += self.session_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.session_rx_socket_stats = io.ttypes.SocketIOStats()
          read_cnt += self.session_rx_socket_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.session_tx_socket_stats = io.ttypes.SocketIOStats()
          read_cnt += self.session_tx_socket_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.msg_type_agg = {}
          (length, _ktype44, _vtype45, _size43 ) = iprot.readMapBegin() 
          read_cnt += length
          for _i47 in xrange(_size43):
            read_cnt += iprot.readContainerElementBegin()
            (length, _key48) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            _val49 = SandeshMessageStats()
            read_cnt += _val49.read(iprot)
            self.msg_type_agg[_key48] = _val49
          read_cnt += iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.MAP:
          self.tx_msg_agg = {}
          (length, _ktype51, _vtype52, _size50 ) = iprot.readMapBegin() 
          read_cnt += length
          for _i54 in xrange(_size50):
            read_cnt += iprot.readContainerElementBegin()
            (length, _key55) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            read_cnt += iprot.readContainerElementBegin()
            (length, _val56) = iprot.readU64();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            self.tx_msg_agg[_key55] = _val56
          read_cnt += iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.U64:
          (length, self.max_sm_queue_count) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.name is not None:
      annotations = {}
      if self._table is None or self._table is '': return -1
      annotations['key'] = self._table
      if oprot.writeFieldBegin('name', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.deleted is not None:
      annotations = {}
      if oprot.writeFieldBegin('deleted', TType.BOOL, 2, annotations) < 0: return -1
      if oprot.writeBool(self.deleted) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.client_info is not None:
      annotations = {}
      if oprot.writeFieldBegin('client_info', TType.STRUCT, 3, annotations) < 0: return -1
      if self.client_info.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.sm_queue_count is not None:
      annotations = {}
      if oprot.writeFieldBegin('sm_queue_count', TType.U64, 5, annotations) < 0: return -1
      if oprot.writeU64(self.sm_queue_count) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.sm_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('sm_stats', TType.STRUCT, 6, annotations) < 0: return -1
      if self.sm_stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.session_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('session_stats', TType.STRUCT, 7, annotations) < 0: return -1
      if self.session_stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.session_rx_socket_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('session_rx_socket_stats', TType.STRUCT, 8, annotations) < 0: return -1
      if self.session_rx_socket_stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.session_tx_socket_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('session_tx_socket_stats', TType.STRUCT, 9, annotations) < 0: return -1
      if self.session_tx_socket_stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.msg_type_agg is not None:
      annotations = {}
      annotations['metric'] = 'agg'
      annotations['tags'] = '.__key'
      if oprot.writeFieldBegin('msg_type_agg', TType.MAP, 10, annotations) < 0: return -1
      if oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.msg_type_agg)) < 0: return -1
      for kiter57,viter58 in self.msg_type_agg.iteritems():
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(kiter57) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
        if viter58.write(oprot) < 0: return -1
      if oprot.writeMapEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.max_sm_queue_count is not None:
      annotations = {}
      if oprot.writeFieldBegin('max_sm_queue_count', TType.U64, 14, annotations) < 0: return -1
      if oprot.writeU64(self.max_sm_queue_count) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.tx_msg_agg is not None:
      annotations = {}
      annotations['metric'] = 'agg'
      annotations['tags'] = '.__key'
      if oprot.writeFieldBegin('tx_msg_agg', TType.MAP, 20, annotations) < 0: return -1
      if oprot.writeMapBegin(TType.STRING, TType.U64, len(self.tx_msg_agg)) < 0: return -1
      for kiter59,viter60 in self.tx_msg_agg.iteritems():
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(kiter59) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeU64(viter60) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeMapEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.name is not None:
      log_str.write('name = ')
      log_str.write(self.name)
      log_str.write('  ')
    if self.deleted is not None:
      log_str.write('deleted = ')
      if self.deleted:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.client_info is not None:
      log_str.write('client_info = ')
      log_str.write('<<  ')
      log_str.write(self.client_info.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.sm_queue_count is not None:
      log_str.write('sm_queue_count = ')
      log_str.write(str(self.sm_queue_count))
      log_str.write('  ')
    if self.sm_stats is not None:
      log_str.write('sm_stats = ')
      log_str.write('<<  ')
      log_str.write(self.sm_stats.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.session_stats is not None:
      log_str.write('session_stats = ')
      log_str.write('<<  ')
      log_str.write(self.session_stats.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.session_rx_socket_stats is not None:
      log_str.write('session_rx_socket_stats = ')
      log_str.write('<<  ')
      log_str.write(self.session_rx_socket_stats.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.session_tx_socket_stats is not None:
      log_str.write('session_tx_socket_stats = ')
      log_str.write('<<  ')
      log_str.write(self.session_tx_socket_stats.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.msg_type_agg is not None:
      log_str.write('msg_type_agg = ')
      log_str.write('{ ')
      for kiter61,viter62 in self.msg_type_agg.iteritems():
        log_str.write(kiter61)
        log_str.write(' : ')
        log_str.write('<<  ')
        log_str.write(viter62.log())
        log_str.write('>>')
      log_str.write(' }')
      log_str.write('  ')
    if self.tx_msg_agg is not None:
      log_str.write('tx_msg_agg = ')
      log_str.write('{ ')
      for kiter63,viter64 in self.tx_msg_agg.iteritems():
        log_str.write(kiter63)
        log_str.write(' : ')
        log_str.write(str(viter64))
      log_str.write(' }')
      log_str.write('  ')
    if self.max_sm_queue_count is not None:
      log_str.write('max_sm_queue_count = ')
      log_str.write(str(self.max_sm_queue_count))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.name is not None:
      size += getsizeof(self.name)
    if self.deleted is not None:
      size += getsizeof(self.deleted)
    if self.client_info is not None:
      size += getsizeof(self.client_info)
    if self.sm_queue_count is not None:
      size += getsizeof(self.sm_queue_count)
    if self.sm_stats is not None:
      size += getsizeof(self.sm_stats)
    if self.session_stats is not None:
      size += getsizeof(self.session_stats)
    if self.session_rx_socket_stats is not None:
      size += getsizeof(self.session_rx_socket_stats)
    if self.session_tx_socket_stats is not None:
      size += getsizeof(self.session_tx_socket_stats)
    if self.msg_type_agg is not None:
      size += getsizeof(self.msg_type_agg)
      size += sum(map(getsizeof, chain.from_iterable(self.msg_type_agg.iteritems())))
    if self.tx_msg_agg is not None:
      size += getsizeof(self.tx_msg_agg)
      size += sum(map(getsizeof, chain.from_iterable(self.tx_msg_agg.iteritems())))
    if self.max_sm_queue_count is not None:
      size += getsizeof(self.max_sm_queue_count)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshMessageStatsReq(sandesh_base.SandeshRequest):

  thrift_spec = (
  )

  def __init__(self, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2471203225
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshMessageStatsReq()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshMessageStatsReq" not implemented')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshMessageStatsReq" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshMessageStatsReq"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    return True

  def __sizeof__(self):
    size = 0
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshMessageStatsResp(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.STRUCT, 'stats', (SandeshGeneratorStats, SandeshGeneratorStats.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'send_queue_stats', (SandeshQueueStats, SandeshQueueStats.thrift_spec), None, ), # 2
    (3, TType.STRING, 'sending_level', None, None, ), # 3
    (4, TType.U64, 'session_close_interval_msec', None, None, ), # 4
    (5, TType.U64, 'session_close_timestamp', None, None, ), # 5
  )

  def __init__(self, stats=None, send_queue_stats=None, sending_level=None, session_close_interval_msec=None, session_close_timestamp=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.stats = stats
    self.send_queue_stats = send_queue_stats
    self.sending_level = sending_level
    self.session_close_interval_msec = session_close_interval_msec
    self.session_close_timestamp = session_close_timestamp
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 4260880511
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.stats is not None:
      log_str.write('stats = ')
      log_str.write('<<  ')
      log_str.write(self.stats.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.send_queue_stats is not None:
      log_str.write('send_queue_stats = ')
      log_str.write('<<  ')
      log_str.write(self.send_queue_stats.log())
      log_str.write('>>')
      log_str.write('  ')
    if self.sending_level is not None:
      log_str.write('sending_level = ')
      log_str.write(self.sending_level)
      log_str.write('  ')
    if self.session_close_interval_msec is not None:
      log_str.write('session_close_interval_msec = ')
      log_str.write(str(self.session_close_interval_msec))
      log_str.write('  ')
    if self.session_close_timestamp is not None:
      log_str.write('session_close_timestamp = ')
      log_str.write(str(self.session_close_timestamp))
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.stats = SandeshGeneratorStats()
          read_cnt += self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.send_queue_stats = SandeshQueueStats()
          read_cnt += self.send_queue_stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.sending_level) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U64:
          (length, self.session_close_interval_msec) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U64:
          (length, self.session_close_timestamp) = iprot.readU64();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('stats', TType.STRUCT, 1, annotations) < 0: return -1
      if self.stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.send_queue_stats is not None:
      annotations = {}
      if oprot.writeFieldBegin('send_queue_stats', TType.STRUCT, 2, annotations) < 0: return -1
      if self.send_queue_stats.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.sending_level is not None:
      annotations = {}
      if oprot.writeFieldBegin('sending_level', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.sending_level) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.session_close_interval_msec is not None:
      annotations = {}
      if oprot.writeFieldBegin('session_close_interval_msec', TType.U64, 4, annotations) < 0: return -1
      if oprot.writeU64(self.session_close_interval_msec) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.session_close_timestamp is not None:
      annotations = {}
      if oprot.writeFieldBegin('session_close_timestamp', TType.U64, 5, annotations) < 0: return -1
      if oprot.writeU64(self.session_close_timestamp) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.stats != other.stats:
      return False
    if self.send_queue_stats != other.send_queue_stats:
      return False
    if self.sending_level != other.sending_level:
      return False
    if self.session_close_interval_msec != other.session_close_interval_msec:
      return False
    if self.session_close_timestamp != other.session_close_timestamp:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.stats is not None:
      size += getsizeof(self.stats)
    if self.send_queue_stats is not None:
      size += getsizeof(self.send_queue_stats)
    if self.sending_level is not None:
      size += getsizeof(self.sending_level)
    if self.session_close_interval_msec is not None:
      size += getsizeof(self.session_close_interval_msec)
    if self.session_close_timestamp is not None:
      size += getsizeof(self.session_close_timestamp)
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshLoggingParamsSet(sandesh_base.SandeshRequest):

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'enable', None, None, ), # 1
    (2, TType.STRING, 'category', None, None, ), # 2
    (3, TType.STRING, 'log_level', None, None, ), # 3
    (4, TType.BOOL, 'trace_print', None, None, ), # 4
    (5, TType.BOOL, 'enable_flow_log', None, None, ), # 5
  )

  def __init__(self, enable=None, category=None, log_level=None, trace_print=None, enable_flow_log=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self.enable = enable
    self.category = category
    self.log_level = log_level
    self.trace_print = trace_print
    self.enable_flow_log = enable_flow_log
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 3395013679
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshLoggingParamsSet()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshLoggingParamsSet" not implemented')
    if bottle.request.query.x:
      try:
        sandesh_req.enable = int(bottle.request.query.x)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.enable:
      try:
        sandesh_req.enable = int(bottle.request.query.enable)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.category:
      sandesh_req.category = str(bottle.request.query.category)
    if bottle.request.query.log_level:
      sandesh_req.log_level = str(bottle.request.query.log_level)
    if bottle.request.query.trace_print:
      try:
        sandesh_req.trace_print = int(bottle.request.query.trace_print)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.enable_flow_log:
      try:
        sandesh_req.enable_flow_log = int(bottle.request.query.enable_flow_log)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshLoggingParamsSet" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshLoggingParamsSet"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.enable is not None:
      log_str.write('enable = ')
      if self.enable:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.category is not None:
      log_str.write('category = ')
      log_str.write(self.category)
      log_str.write('  ')
    if self.log_level is not None:
      log_str.write('log_level = ')
      log_str.write(self.log_level)
      log_str.write('  ')
    if self.trace_print is not None:
      log_str.write('trace_print = ')
      if self.trace_print:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.enable_flow_log is not None:
      log_str.write('enable_flow_log = ')
      if self.enable_flow_log:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          (length, self.enable) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.category) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.log_level) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          (length, self.trace_print) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          (length, self.enable_flow_log) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.enable is not None:
      annotations = {}
      if oprot.writeFieldBegin('enable', TType.BOOL, 1, annotations) < 0: return -1
      if oprot.writeBool(self.enable) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.category is not None:
      annotations = {}
      if oprot.writeFieldBegin('category', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.category) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.log_level is not None:
      annotations = {}
      if oprot.writeFieldBegin('log_level', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.log_level) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.trace_print is not None:
      annotations = {}
      if oprot.writeFieldBegin('trace_print', TType.BOOL, 4, annotations) < 0: return -1
      if oprot.writeBool(self.trace_print) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.enable_flow_log is not None:
      annotations = {}
      if oprot.writeFieldBegin('enable_flow_log', TType.BOOL, 5, annotations) < 0: return -1
      if oprot.writeBool(self.enable_flow_log) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.enable != other.enable:
      return False
    if self.category != other.category:
      return False
    if self.log_level != other.log_level:
      return False
    if self.trace_print != other.trace_print:
      return False
    if self.enable_flow_log != other.enable_flow_log:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.enable is not None:
      size += getsizeof(self.enable)
    if self.category is not None:
      size += getsizeof(self.category)
    if self.log_level is not None:
      size += getsizeof(self.log_level)
    if self.trace_print is not None:
      size += getsizeof(self.trace_print)
    if self.enable_flow_log is not None:
      size += getsizeof(self.enable_flow_log)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshLoggingParamsStatus(sandesh_base.SandeshRequest):

  thrift_spec = (
  )

  def __init__(self, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2471203225
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshLoggingParamsStatus()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshLoggingParamsStatus" not implemented')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshLoggingParamsStatus" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshLoggingParamsStatus"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    return True

  def __sizeof__(self):
    size = 0
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshLoggingParams(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.BOOL, 'enable', None, None, ), # 1
    (2, TType.STRING, 'category', None, None, ), # 2
    (3, TType.STRING, 'log_level', None, None, ), # 3
    (4, TType.BOOL, 'trace_print', None, None, ), # 4
    (5, TType.BOOL, 'enable_flow_log', None, None, ), # 5
  )

  def __init__(self, enable=None, category=None, log_level=None, trace_print=None, enable_flow_log=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.enable = enable
    self.category = category
    self.log_level = log_level
    self.trace_print = trace_print
    self.enable_flow_log = enable_flow_log
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 606006411
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.enable is not None:
      log_str.write('enable = ')
      if self.enable:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.category is not None:
      log_str.write('category = ')
      log_str.write(self.category)
      log_str.write('  ')
    if self.log_level is not None:
      log_str.write('log_level = ')
      log_str.write(self.log_level)
      log_str.write('  ')
    if self.trace_print is not None:
      log_str.write('trace_print = ')
      if self.trace_print:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.enable_flow_log is not None:
      log_str.write('enable_flow_log = ')
      if self.enable_flow_log:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          (length, self.enable) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.category) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.log_level) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          (length, self.trace_print) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          (length, self.enable_flow_log) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.enable is not None:
      annotations = {}
      if oprot.writeFieldBegin('enable', TType.BOOL, 1, annotations) < 0: return -1
      if oprot.writeBool(self.enable) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.category is not None:
      annotations = {}
      if oprot.writeFieldBegin('category', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.category) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.log_level is not None:
      annotations = {}
      if oprot.writeFieldBegin('log_level', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.log_level) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.trace_print is not None:
      annotations = {}
      if oprot.writeFieldBegin('trace_print', TType.BOOL, 4, annotations) < 0: return -1
      if oprot.writeBool(self.trace_print) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.enable_flow_log is not None:
      annotations = {}
      if oprot.writeFieldBegin('enable_flow_log', TType.BOOL, 5, annotations) < 0: return -1
      if oprot.writeBool(self.enable_flow_log) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.enable != other.enable:
      return False
    if self.category != other.category:
      return False
    if self.log_level != other.log_level:
      return False
    if self.trace_print != other.trace_print:
      return False
    if self.enable_flow_log != other.enable_flow_log:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.enable is not None:
      size += getsizeof(self.enable)
    if self.category is not None:
      size += getsizeof(self.category)
    if self.log_level is not None:
      size += getsizeof(self.log_level)
    if self.trace_print is not None:
      size += getsizeof(self.trace_print)
    if self.enable_flow_log is not None:
      size += getsizeof(self.enable_flow_log)
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSendingParamsSet(sandesh_base.SandeshRequest):

  thrift_spec = (
    None, # 0
    (1, TType.U32, 'system_logs_rate_limit', None, None, ), # 1
    (2, TType.BOOL, 'disable_object_logs', None, None, ), # 2
    (3, TType.BOOL, 'disable_all_logs', None, None, ), # 3
    (4, TType.BOOL, 'disable_flows', None, None, ), # 4
  )

  def __init__(self, system_logs_rate_limit=None, disable_object_logs=None, disable_all_logs=None, disable_flows=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self.system_logs_rate_limit = system_logs_rate_limit
    self.disable_object_logs = disable_object_logs
    self.disable_all_logs = disable_all_logs
    self.disable_flows = disable_flows
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 3737696477
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshSendingParamsSet()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendingParamsSet" not implemented')
    if bottle.request.query.x:
      try:
        sandesh_req.system_logs_rate_limit = int(bottle.request.query.x)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.system_logs_rate_limit:
      try:
        sandesh_req.system_logs_rate_limit = int(bottle.request.query.system_logs_rate_limit)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.disable_object_logs:
      try:
        sandesh_req.disable_object_logs = int(bottle.request.query.disable_object_logs)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.disable_all_logs:
      try:
        sandesh_req.disable_all_logs = int(bottle.request.query.disable_all_logs)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.disable_flows:
      try:
        sandesh_req.disable_flows = int(bottle.request.query.disable_flows)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendingParamsSet" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshSendingParamsSet"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.system_logs_rate_limit is not None:
      log_str.write('system_logs_rate_limit = ')
      log_str.write(str(self.system_logs_rate_limit))
      log_str.write('  ')
    if self.disable_object_logs is not None:
      log_str.write('disable_object_logs = ')
      if self.disable_object_logs:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.disable_all_logs is not None:
      log_str.write('disable_all_logs = ')
      if self.disable_all_logs:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.disable_flows is not None:
      log_str.write('disable_flows = ')
      if self.disable_flows:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U32:
          (length, self.system_logs_rate_limit) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          (length, self.disable_object_logs) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          (length, self.disable_all_logs) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          (length, self.disable_flows) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.system_logs_rate_limit is not None:
      annotations = {}
      if oprot.writeFieldBegin('system_logs_rate_limit', TType.U32, 1, annotations) < 0: return -1
      if oprot.writeU32(self.system_logs_rate_limit) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.disable_object_logs is not None:
      annotations = {}
      if oprot.writeFieldBegin('disable_object_logs', TType.BOOL, 2, annotations) < 0: return -1
      if oprot.writeBool(self.disable_object_logs) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.disable_all_logs is not None:
      annotations = {}
      if oprot.writeFieldBegin('disable_all_logs', TType.BOOL, 3, annotations) < 0: return -1
      if oprot.writeBool(self.disable_all_logs) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.disable_flows is not None:
      annotations = {}
      if oprot.writeFieldBegin('disable_flows', TType.BOOL, 4, annotations) < 0: return -1
      if oprot.writeBool(self.disable_flows) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.system_logs_rate_limit != other.system_logs_rate_limit:
      return False
    if self.disable_object_logs != other.disable_object_logs:
      return False
    if self.disable_all_logs != other.disable_all_logs:
      return False
    if self.disable_flows != other.disable_flows:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.system_logs_rate_limit is not None:
      size += getsizeof(self.system_logs_rate_limit)
    if self.disable_object_logs is not None:
      size += getsizeof(self.disable_object_logs)
    if self.disable_all_logs is not None:
      size += getsizeof(self.disable_all_logs)
    if self.disable_flows is not None:
      size += getsizeof(self.disable_flows)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSendingParamsStatus(sandesh_base.SandeshRequest):

  thrift_spec = (
  )

  def __init__(self, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2471203225
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshSendingParamsStatus()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendingParamsStatus" not implemented')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendingParamsStatus" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshSendingParamsStatus"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    return True

  def __sizeof__(self):
    size = 0
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSendingParams(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.U32, 'system_logs_rate_limit', None, None, ), # 1
    (2, TType.BOOL, 'disable_object_logs', None, None, ), # 2
    (3, TType.BOOL, 'disable_all_logs', None, None, ), # 3
    (4, TType.U16, 'dscp', None, None, ), # 4
    (5, TType.BOOL, 'disable_flows', None, None, ), # 5
  )

  def __init__(self, system_logs_rate_limit=None, disable_object_logs=None, disable_all_logs=None, dscp=None, disable_flows=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.system_logs_rate_limit = system_logs_rate_limit
    self.disable_object_logs = disable_object_logs
    self.disable_all_logs = disable_all_logs
    self.dscp = dscp
    self.disable_flows = disable_flows
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 3931927235
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.system_logs_rate_limit is not None:
      log_str.write('system_logs_rate_limit = ')
      log_str.write(str(self.system_logs_rate_limit))
      log_str.write('  ')
    if self.disable_object_logs is not None:
      log_str.write('disable_object_logs = ')
      if self.disable_object_logs:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.disable_all_logs is not None:
      log_str.write('disable_all_logs = ')
      if self.disable_all_logs:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.dscp is not None:
      log_str.write('dscp = ')
      log_str.write(str(self.dscp))
      log_str.write('  ')
    if self.disable_flows is not None:
      log_str.write('disable_flows = ')
      if self.disable_flows:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U32:
          (length, self.system_logs_rate_limit) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          (length, self.disable_object_logs) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          (length, self.disable_all_logs) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.U16:
          (length, self.dscp) = iprot.readU16();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          (length, self.disable_flows) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.system_logs_rate_limit is not None:
      annotations = {}
      if oprot.writeFieldBegin('system_logs_rate_limit', TType.U32, 1, annotations) < 0: return -1
      if oprot.writeU32(self.system_logs_rate_limit) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.disable_object_logs is not None:
      annotations = {}
      if oprot.writeFieldBegin('disable_object_logs', TType.BOOL, 2, annotations) < 0: return -1
      if oprot.writeBool(self.disable_object_logs) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.disable_all_logs is not None:
      annotations = {}
      if oprot.writeFieldBegin('disable_all_logs', TType.BOOL, 3, annotations) < 0: return -1
      if oprot.writeBool(self.disable_all_logs) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.dscp is not None:
      annotations = {}
      if oprot.writeFieldBegin('dscp', TType.U16, 4, annotations) < 0: return -1
      if oprot.writeU16(self.dscp) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.disable_flows is not None:
      annotations = {}
      if oprot.writeFieldBegin('disable_flows', TType.BOOL, 5, annotations) < 0: return -1
      if oprot.writeBool(self.disable_flows) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.system_logs_rate_limit != other.system_logs_rate_limit:
      return False
    if self.disable_object_logs != other.disable_object_logs:
      return False
    if self.disable_all_logs != other.disable_all_logs:
      return False
    if self.dscp != other.dscp:
      return False
    if self.disable_flows != other.disable_flows:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.system_logs_rate_limit is not None:
      size += getsizeof(self.system_logs_rate_limit)
    if self.disable_object_logs is not None:
      size += getsizeof(self.disable_object_logs)
    if self.disable_all_logs is not None:
      size += getsizeof(self.disable_all_logs)
    if self.dscp is not None:
      size += getsizeof(self.dscp)
    if self.disable_flows is not None:
      size += getsizeof(self.disable_flows)
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSendQueueParamsSet(sandesh_base.SandeshRequest):

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'high', None, None, ), # 1
    (2, TType.U32, 'queue_count', None, None, ), # 2
    (3, TType.STRING, 'sending_level', None, None, ), # 3
  )

  def __init__(self, high=None, queue_count=None, sending_level=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self.high = high
    self.queue_count = queue_count
    self.sending_level = sending_level
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 3248463448
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshSendQueueParamsSet()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendQueueParamsSet" not implemented')
    if bottle.request.query.x:
      try:
        sandesh_req.high = int(bottle.request.query.x)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.high:
      try:
        sandesh_req.high = int(bottle.request.query.high)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.queue_count:
      try:
        sandesh_req.queue_count = int(bottle.request.query.queue_count)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.sending_level:
      sandesh_req.sending_level = str(bottle.request.query.sending_level)
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendQueueParamsSet" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshSendQueueParamsSet"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.high is not None:
      log_str.write('high = ')
      if self.high:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.queue_count is not None:
      log_str.write('queue_count = ')
      log_str.write(str(self.queue_count))
      log_str.write('  ')
    if self.sending_level is not None:
      log_str.write('sending_level = ')
      log_str.write(self.sending_level)
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          (length, self.high) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U32:
          (length, self.queue_count) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.sending_level) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.high is not None:
      annotations = {}
      if oprot.writeFieldBegin('high', TType.BOOL, 1, annotations) < 0: return -1
      if oprot.writeBool(self.high) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.queue_count is not None:
      annotations = {}
      if oprot.writeFieldBegin('queue_count', TType.U32, 2, annotations) < 0: return -1
      if oprot.writeU32(self.queue_count) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.sending_level is not None:
      annotations = {}
      if oprot.writeFieldBegin('sending_level', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.sending_level) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.high != other.high:
      return False
    if self.queue_count != other.queue_count:
      return False
    if self.sending_level != other.sending_level:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.high is not None:
      size += getsizeof(self.high)
    if self.queue_count is not None:
      size += getsizeof(self.queue_count)
    if self.sending_level is not None:
      size += getsizeof(self.sending_level)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSendQueueParamsReset(sandesh_base.SandeshRequest):

  thrift_spec = (
  )

  def __init__(self, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2471203225
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshSendQueueParamsReset()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendQueueParamsReset" not implemented')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendQueueParamsReset" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshSendQueueParamsReset"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    return True

  def __sizeof__(self):
    size = 0
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSendQueueParamsStatus(sandesh_base.SandeshRequest):

  thrift_spec = (
  )

  def __init__(self, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2471203225
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshSendQueueParamsStatus()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendQueueParamsStatus" not implemented')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendQueueParamsStatus" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshSendQueueParamsStatus"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    return True

  def __sizeof__(self):
    size = 0
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSendQueueParamsResponse(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.LIST, 'info', (TType.STRUCT,(SandeshSendQueueParams, SandeshSendQueueParams.thrift_spec)), None, ), # 1
  )

  def __init__(self, info=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.info = info
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 3603236461
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.info is not None:
      log_str.write('info = ')
      log_str.write('[ ')
      for iter65 in self.info:
        log_str.write('<<  ')
        log_str.write(iter65.log())
        log_str.write('>>')
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.info = []
          (length, _etype69, _size66) = iprot.readListBegin()
          read_cnt += length
          for _i70 in xrange(_size66):
            _elem71 = SandeshSendQueueParams()
            read_cnt += _elem71.read(iprot)
            self.info.append(_elem71)
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.info is not None:
      annotations = {}
      if oprot.writeFieldBegin('info', TType.LIST, 1, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRUCT, len(self.info)) < 0: return -1
      for iter72 in self.info:
        if iter72.write(oprot) < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.info != other.info:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.info is not None:
      size += getsizeof(self.info)
      size += sum(map(getsizeof, self.info))
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSendQueueSet(sandesh_base.SandeshRequest):

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'enable', None, None, ), # 1
  )

  def __init__(self, enable=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self.enable = enable
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 1380320703
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshSendQueueSet()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendQueueSet" not implemented')
    if bottle.request.query.x:
      try:
        sandesh_req.enable = int(bottle.request.query.x)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.enable:
      try:
        sandesh_req.enable = int(bottle.request.query.enable)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendQueueSet" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshSendQueueSet"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.enable is not None:
      log_str.write('enable = ')
      if self.enable:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          (length, self.enable) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.enable is not None:
      annotations = {}
      if oprot.writeFieldBegin('enable', TType.BOOL, 1, annotations) < 0: return -1
      if oprot.writeBool(self.enable) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.enable != other.enable:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.enable is not None:
      size += getsizeof(self.enable)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSendQueueStatus(sandesh_base.SandeshRequest):

  thrift_spec = (
  )

  def __init__(self, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2471203225
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshSendQueueStatus()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendQueueStatus" not implemented')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshSendQueueStatus" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshSendQueueStatus"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    return True

  def __sizeof__(self):
    size = 0
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshSendQueueResponse(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.BOOL, 'enable', None, None, ), # 1
  )

  def __init__(self, enable=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.enable = enable
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 4224038448
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.enable is not None:
      log_str.write('enable = ')
      if self.enable:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          (length, self.enable) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.enable is not None:
      annotations = {}
      if oprot.writeFieldBegin('enable', TType.BOOL, 1, annotations) < 0: return -1
      if oprot.writeBool(self.enable) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.enable != other.enable:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.enable is not None:
      size += getsizeof(self.enable)
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CollectorInfoRequest(sandesh_base.SandeshRequest):

  thrift_spec = (
  )

  def __init__(self, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2471203225
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = CollectorInfoRequest()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "CollectorInfoRequest" not implemented')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "CollectorInfoRequest" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "CollectorInfoRequest"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    return True

  def __sizeof__(self):
    size = 0
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CollectorInfoResponse(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.STRING, 'ip', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.STRING, 'status', None, None, ), # 3
  )

  def __init__(self, ip=None, port=None, status=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.ip = ip
    self.port = port
    self.status = status
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 1757911211
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.ip is not None:
      log_str.write('ip = ')
      log_str.write(self.ip)
      log_str.write('  ')
    if self.port is not None:
      log_str.write('port = ')
      log_str.write(str(self.port))
      log_str.write('  ')
    if self.status is not None:
      log_str.write('status = ')
      log_str.write(self.status)
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.ip) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          (length, self.port) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.status) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.ip is not None:
      annotations = {}
      if oprot.writeFieldBegin('ip', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.ip) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.port is not None:
      annotations = {}
      if oprot.writeFieldBegin('port', TType.I32, 2, annotations) < 0: return -1
      if oprot.writeI32(self.port) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.status is not None:
      annotations = {}
      if oprot.writeFieldBegin('status', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.status) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.ip != other.ip:
      return False
    if self.port != other.port:
      return False
    if self.status != other.status:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.ip is not None:
      size += getsizeof(self.ip)
    if self.port is not None:
      size += getsizeof(self.port)
    if self.status is not None:
      size += getsizeof(self.status)
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshUVEDSConfReq(sandesh_base.SandeshRequest):

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tname', None, None, ), # 1
    (2, TType.STRING, 'dsattr', None, None, ), # 2
    (3, TType.STRING, 'dsconf', None, None, ), # 3
  )

  def __init__(self, tname=None, dsattr=None, dsconf=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self.tname = tname
    self.dsattr = dsattr
    self.dsconf = dsconf
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 1083803563
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshUVEDSConfReq()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshUVEDSConfReq" not implemented')
    if bottle.request.query.x:
      sandesh_req.tname = str(bottle.request.query.x)
    if bottle.request.query.tname:
      sandesh_req.tname = str(bottle.request.query.tname)
    if bottle.request.query.dsattr:
      sandesh_req.dsattr = str(bottle.request.query.dsattr)
    if bottle.request.query.dsconf:
      sandesh_req.dsconf = str(bottle.request.query.dsconf)
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshUVEDSConfReq" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshUVEDSConfReq"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.tname is not None:
      log_str.write('tname = ')
      log_str.write(self.tname)
      log_str.write('  ')
    if self.dsattr is not None:
      log_str.write('dsattr = ')
      log_str.write(self.dsattr)
      log_str.write('  ')
    if self.dsconf is not None:
      log_str.write('dsconf = ')
      log_str.write(self.dsconf)
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.tname) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.dsattr) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          (length, self.dsconf) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.tname is not None:
      annotations = {}
      if oprot.writeFieldBegin('tname', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.tname) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.dsattr is not None:
      annotations = {}
      if oprot.writeFieldBegin('dsattr', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.dsattr) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.dsconf is not None:
      annotations = {}
      if oprot.writeFieldBegin('dsconf', TType.STRING, 3, annotations) < 0: return -1
      if oprot.writeString(self.dsconf) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.tname != other.tname:
      return False
    if self.dsattr != other.dsattr:
      return False
    if self.dsconf != other.dsconf:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.tname is not None:
      size += getsizeof(self.tname)
    if self.dsattr is not None:
      size += getsizeof(self.dsattr)
    if self.dsconf is not None:
      size += getsizeof(self.dsconf)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshUVEDSConfResp(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
    (2, TType.MAP, 'dsconf', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, success=None, dsconf=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.success = success
    self.dsconf = dsconf
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 4291561876
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.success is not None:
      log_str.write('success = ')
      if self.success:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    if self.dsconf is not None:
      log_str.write('dsconf = ')
      log_str.write('{ ')
      for kiter73,viter74 in self.dsconf.iteritems():
        log_str.write(kiter73)
        log_str.write(' : ')
        log_str.write(viter74)
      log_str.write(' }')
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          (length, self.success) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.dsconf = {}
          (length, _ktype76, _vtype77, _size75 ) = iprot.readMapBegin() 
          read_cnt += length
          for _i79 in xrange(_size75):
            read_cnt += iprot.readContainerElementBegin()
            (length, _key80) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            read_cnt += iprot.readContainerElementBegin()
            (length, _val81) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            read_cnt += iprot.readContainerElementEnd()
            self.dsconf[_key80] = _val81
          read_cnt += iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.success is not None:
      annotations = {}
      if oprot.writeFieldBegin('success', TType.BOOL, 1, annotations) < 0: return -1
      if oprot.writeBool(self.success) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.dsconf is not None:
      annotations = {}
      if oprot.writeFieldBegin('dsconf', TType.MAP, 2, annotations) < 0: return -1
      if oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.dsconf)) < 0: return -1
      for kiter82,viter83 in self.dsconf.iteritems():
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(kiter82) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(viter83) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeMapEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.success != other.success:
      return False
    if self.dsconf != other.dsconf:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.success is not None:
      size += getsizeof(self.success)
    if self.dsconf is not None:
      size += getsizeof(self.dsconf)
      size += sum(map(getsizeof, chain.from_iterable(self.dsconf.iteritems())))
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshUVECacheReq(sandesh_base.SandeshRequest):

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tname', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
  )

  def __init__(self, tname=None, key=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self.tname = tname
    self.key = key
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2508877915
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshUVECacheReq()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshUVECacheReq" not implemented')
    if bottle.request.query.x:
      sandesh_req.tname = str(bottle.request.query.x)
    if bottle.request.query.tname:
      sandesh_req.tname = str(bottle.request.query.tname)
    if bottle.request.query.key:
      sandesh_req.key = str(bottle.request.query.key)
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshUVECacheReq" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshUVECacheReq"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.tname is not None:
      log_str.write('tname = ')
      log_str.write(self.tname)
      log_str.write('  ')
    if self.key is not None:
      log_str.write('key = ')
      log_str.write(self.key)
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.tname) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.key) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.tname is not None:
      annotations = {}
      if oprot.writeFieldBegin('tname', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.tname) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.key is not None:
      annotations = {}
      if oprot.writeFieldBegin('key', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.key) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.tname != other.tname:
      return False
    if self.key != other.key:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.tname is not None:
      size += getsizeof(self.tname)
    if self.key is not None:
      size += getsizeof(self.key)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshUVECacheResp(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.U32, 'returned', None, None, ), # 1
    (2, TType.I32, 'period', None, None, ), # 2
  )

  def __init__(self, returned=None, period=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.returned = returned
    self.period = period
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 1754370719
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.returned is not None:
      log_str.write('returned = ')
      log_str.write(str(self.returned))
      log_str.write('  ')
    if self.period is not None:
      log_str.write('period = ')
      log_str.write(str(self.period))
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.U32:
          (length, self.returned) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          (length, self.period) = iprot.readI32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.returned is not None:
      annotations = {}
      if oprot.writeFieldBegin('returned', TType.U32, 1, annotations) < 0: return -1
      if oprot.writeU32(self.returned) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.period is not None:
      annotations = {}
      if oprot.writeFieldBegin('period', TType.I32, 2, annotations) < 0: return -1
      if oprot.writeI32(self.period) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.returned != other.returned:
      return False
    if self.period != other.period:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.returned is not None:
      size += getsizeof(self.returned)
    if self.period is not None:
      size += getsizeof(self.period)
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshUVETypesReq(sandesh_base.SandeshRequest):

  thrift_spec = (
  )

  def __init__(self, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 2471203225
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshUVETypesReq()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshUVETypesReq" not implemented')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshUVETypesReq" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshUVETypesReq"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    return True

  def __sizeof__(self):
    size = 0
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshUVETypesResp(sandesh_base.SandeshResponse):

  thrift_spec = (
    (0, TType.BOOL, 'more', None, None, ), # 0
    (1, TType.LIST, 'type_info', (TType.STRUCT,(SandeshUVETypeInfo, SandeshUVETypeInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, type_info=None, more=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshResponse.__init__(self)
    self.type_info = type_info
    self.more = more
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 1725589382
    self._hints = 0

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.type_info is not None:
      log_str.write('type_info = ')
      log_str.write('[ ')
      for iter84 in self.type_info:
        log_str.write('<<  ')
        log_str.write(iter84.log())
        log_str.write('>>')
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.more is not None:
      log_str.write('more = ')
      if self.more:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.type_info = []
          (length, _etype88, _size85) = iprot.readListBegin()
          read_cnt += length
          for _i89 in xrange(_size85):
            _elem90 = SandeshUVETypeInfo()
            read_cnt += _elem90.read(iprot)
            self.type_info.append(_elem90)
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 0:
        if ftype == TType.BOOL:
          (length, self.more) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.more is not None:
      annotations = {}
      if oprot.writeFieldBegin('more', TType.BOOL, 0, annotations) < 0: return -1
      if oprot.writeBool(self.more) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.type_info is not None:
      annotations = {}
      if oprot.writeFieldBegin('type_info', TType.LIST, 1, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRUCT, len(self.type_info)) < 0: return -1
      for iter91 in self.type_info:
        if iter91.write(oprot) < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.more != other.more:
      return False
    if self.type_info != other.type_info:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.type_info is not None:
      size += getsizeof(self.type_info)
      size += sum(map(getsizeof, self.type_info))
    if self.more is not None:
      size += getsizeof(self.more)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshModuleClientTrace(sandesh_base.SandeshUVE):

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'data', (ModuleClientState, ModuleClientState.thrift_spec), None, ), # 1
  )

  def __init__(self, data=None, table=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshUVE.__init__(self)
    self.data = data
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 610581904
    self._hints = 0 | SANDESH_KEY_HINT
    if table is not None:
      self.data._table = table

  def update_uve(self, tdata):
    if self.data.name is not None:
      tdata.name = self.data.name
    if self.data.deleted is not None:
      tdata.deleted = self.data.deleted
    if self.data.client_info is not None:
      tdata.client_info = self.data.client_info
    if self.data.sm_queue_count is not None:
      tdata.sm_queue_count = self.data.sm_queue_count
    if self.data.sm_stats is not None:
      tdata.sm_stats = self.data.sm_stats
    if self.data.session_stats is not None:
      tdata.session_stats = self.data.session_stats
    if self.data.session_rx_socket_stats is not None:
      tdata.session_rx_socket_stats = self.data.session_rx_socket_stats
    if self.data.session_tx_socket_stats is not None:
      tdata.session_tx_socket_stats = self.data.session_tx_socket_stats
    if self.data.msg_type_agg is not None:
      tdata.msg_type_agg = self.data.msg_type_agg
    if self.data.tx_msg_agg is not None:
      tdata.tx_msg_agg = self.data.tx_msg_agg
    if self.data.max_sm_queue_count is not None:
      tdata.max_sm_queue_count = self.data.max_sm_queue_count
    return tdata

  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.data is not None:
      log_str.write('data = ')
      log_str.write('<<  ')
      log_str.write(self.data.log())
      log_str.write('>>')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data = ModuleClientState()
          read_cnt += self.data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.data is not None:
      annotations = {}
      if oprot.writeFieldBegin('data', TType.STRUCT, 1, annotations) < 0: return -1
      if self.data.write(oprot) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.data != other.data:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.data is not None:
      size += getsizeof(self.data)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


_SANDESH_REQUEST_LIST = [
SandeshMessageStatsReq,
SandeshLoggingParamsSet,
SandeshLoggingParamsStatus,
SandeshSendingParamsSet,
SandeshSendingParamsStatus,
SandeshSendQueueParamsSet,
SandeshSendQueueParamsReset,
SandeshSendQueueParamsStatus,
SandeshSendQueueSet,
SandeshSendQueueStatus,
CollectorInfoRequest,
SandeshUVEDSConfReq,
SandeshUVECacheReq,
SandeshUVETypesReq,
]


_SANDESH_UVE_LIST = [
(SandeshModuleClientTrace, ModuleClientState),
]


_SANDESH_ALARM_LIST = [
]
