#
# Autogenerated by Sandesh Compiler (1.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#

from pysandesh.Thrift import TType, TMessageType, TException

from pysandesh.transport import TTransport
from pysandesh.protocol import TBinaryProtocol, TProtocol
try:
  from pysandesh.protocol import fastbinary
except:
  fastbinary = None

import cStringIO
import uuid
import netaddr
from sys import getsizeof
from itertools import chain
import bottle
from pysandesh import sandesh_base
from pysandesh.sandesh_http import SandeshHttp
from pysandesh.sandesh_uve import SandeshUVETypeMaps
from pysandesh.util import UTCTimestampUsec, UTCTimestampUsecToString
from pysandesh import util
from pysandesh.gen_py.sandesh.constants import *



class UVETypeInfo(object):
  """
  Attributes:
   - type_name
   - seq_num
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'type_name', None, None, ), # 1
    (2, TType.U32, 'seq_num', None, None, ), # 2
  )

  def __init__(self, type_name=None, seq_num=None,):
    self.type_name = type_name
    self.seq_num = seq_num

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return 0
    read_cnt = 0
    length = iprot.readStructBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.type_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.U32:
          (length, self.seq_num) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readStructEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeStructBegin(self.__class__.__name__) < 0: return -1
    if self.type_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('type_name', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.type_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.seq_num is not None:
      annotations = {}
      if oprot.writeFieldBegin('seq_num', TType.U32, 2, annotations) < 0: return -1
      if oprot.writeU32(self.seq_num) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeStructEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def log(self):
    log_str = cStringIO.StringIO()
    if self.type_name is not None:
      log_str.write('type_name = ')
      log_str.write(self.type_name)
      log_str.write('  ')
    if self.seq_num is not None:
      log_str.write('seq_num = ')
      log_str.write(str(self.seq_num))
      log_str.write('  ')
    return log_str.getvalue()

  def __sizeof__(self):
    size = 0
    if self.type_name is not None:
      size += getsizeof(self.type_name)
    if self.seq_num is not None:
      size += getsizeof(self.seq_num)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshCtrlClientToServer(sandesh_base.SandeshRequest):

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'source', None, None, ), # 1
    (2, TType.STRING, 'module_name', None, None, ), # 2
    (3, TType.U32, 'sucessful_connections', None, None, ), # 3
    (4, TType.LIST, 'uve_types', (TType.STRING,None), None, ), # 4
    (5, TType.U32, 'pid', None, None, ), # 5
    (6, TType.U32, 'http_port', None, None, ), # 6
    (7, TType.STRING, 'node_type_name', None, None, ), # 7
    (8, TType.STRING, 'instance_id_name', None, None, ), # 8
  )

  def __init__(self, source=None, module_name=None, sucessful_connections=None, uve_types=None, pid=None, http_port=None, node_type_name=None, instance_id_name=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self.source = source
    self.module_name = module_name
    self.sucessful_connections = sucessful_connections
    self.uve_types = uve_types
    self.pid = pid
    self.http_port = http_port
    self.node_type_name = node_type_name
    self.instance_id_name = instance_id_name
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 3954722166
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshCtrlClientToServer()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshCtrlClientToServer" not implemented')
    if bottle.request.query.x:
      sandesh_req.source = str(bottle.request.query.x)
    if bottle.request.query.source:
      sandesh_req.source = str(bottle.request.query.source)
    if bottle.request.query.module_name:
      sandesh_req.module_name = str(bottle.request.query.module_name)
    if bottle.request.query.sucessful_connections:
      try:
        sandesh_req.sucessful_connections = int(bottle.request.query.sucessful_connections)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.pid:
      try:
        sandesh_req.pid = int(bottle.request.query.pid)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.http_port:
      try:
        sandesh_req.http_port = int(bottle.request.query.http_port)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    if bottle.request.query.node_type_name:
      sandesh_req.node_type_name = str(bottle.request.query.node_type_name)
    if bottle.request.query.instance_id_name:
      sandesh_req.instance_id_name = str(bottle.request.query.instance_id_name)
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshCtrlClientToServer" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshCtrlClientToServer"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.source is not None:
      log_str.write('source = ')
      log_str.write(self.source)
      log_str.write('  ')
    if self.module_name is not None:
      log_str.write('module_name = ')
      log_str.write(self.module_name)
      log_str.write('  ')
    if self.sucessful_connections is not None:
      log_str.write('sucessful_connections = ')
      log_str.write(str(self.sucessful_connections))
      log_str.write('  ')
    if self.uve_types is not None:
      log_str.write('uve_types = ')
      log_str.write('[ ')
      for iter0 in self.uve_types:
        log_str.write(iter0)
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.pid is not None:
      log_str.write('pid = ')
      log_str.write(str(self.pid))
      log_str.write('  ')
    if self.http_port is not None:
      log_str.write('http_port = ')
      log_str.write(str(self.http_port))
      log_str.write('  ')
    if self.node_type_name is not None:
      log_str.write('node_type_name = ')
      log_str.write(self.node_type_name)
      log_str.write('  ')
    if self.instance_id_name is not None:
      log_str.write('instance_id_name = ')
      log_str.write(self.instance_id_name)
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          (length, self.source) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          (length, self.module_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.U32:
          (length, self.sucessful_connections) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.uve_types = []
          (length, _etype4, _size1) = iprot.readListBegin()
          read_cnt += length
          for _i5 in xrange(_size1):
            read_cnt += iprot.readContainerElementBegin()
            (length, _elem6) = iprot.readString();
            if length < 0: return -1
            read_cnt += length
            self.uve_types.append(_elem6)
            read_cnt += iprot.readContainerElementEnd()
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.U32:
          (length, self.pid) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.U32:
          (length, self.http_port) = iprot.readU32();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          (length, self.node_type_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          (length, self.instance_id_name) = iprot.readString();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.source is not None:
      annotations = {}
      if oprot.writeFieldBegin('source', TType.STRING, 1, annotations) < 0: return -1
      if oprot.writeString(self.source) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.module_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('module_name', TType.STRING, 2, annotations) < 0: return -1
      if oprot.writeString(self.module_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.sucessful_connections is not None:
      annotations = {}
      if oprot.writeFieldBegin('sucessful_connections', TType.U32, 3, annotations) < 0: return -1
      if oprot.writeU32(self.sucessful_connections) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.uve_types is not None:
      annotations = {}
      if oprot.writeFieldBegin('uve_types', TType.LIST, 4, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRING, len(self.uve_types)) < 0: return -1
      for iter7 in self.uve_types:
        if oprot.writeContainerElementBegin() < 0: return -1
        if oprot.writeString(iter7) < 0: return -1
        if oprot.writeContainerElementEnd() < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.pid is not None:
      annotations = {}
      if oprot.writeFieldBegin('pid', TType.U32, 5, annotations) < 0: return -1
      if oprot.writeU32(self.pid) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.http_port is not None:
      annotations = {}
      if oprot.writeFieldBegin('http_port', TType.U32, 6, annotations) < 0: return -1
      if oprot.writeU32(self.http_port) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.node_type_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('node_type_name', TType.STRING, 7, annotations) < 0: return -1
      if oprot.writeString(self.node_type_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.instance_id_name is not None:
      annotations = {}
      if oprot.writeFieldBegin('instance_id_name', TType.STRING, 8, annotations) < 0: return -1
      if oprot.writeString(self.instance_id_name) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.source != other.source:
      return False
    if self.module_name != other.module_name:
      return False
    if self.sucessful_connections != other.sucessful_connections:
      return False
    if self.uve_types != other.uve_types:
      return False
    if self.pid != other.pid:
      return False
    if self.http_port != other.http_port:
      return False
    if self.node_type_name != other.node_type_name:
      return False
    if self.instance_id_name != other.instance_id_name:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.source is not None:
      size += getsizeof(self.source)
    if self.module_name is not None:
      size += getsizeof(self.module_name)
    if self.sucessful_connections is not None:
      size += getsizeof(self.sucessful_connections)
    if self.uve_types is not None:
      size += getsizeof(self.uve_types)
      size += sum(map(getsizeof, self.uve_types))
    if self.pid is not None:
      size += getsizeof(self.pid)
    if self.http_port is not None:
      size += getsizeof(self.http_port)
    if self.node_type_name is not None:
      size += getsizeof(self.node_type_name)
    if self.instance_id_name is not None:
      size += getsizeof(self.instance_id_name)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SandeshCtrlServerToClient(sandesh_base.SandeshRequest):

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'type_info', (TType.STRUCT,(UVETypeInfo, UVETypeInfo.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'success', None, None, ), # 2
  )

  def __init__(self, type_info=None, success=None, sandesh=sandesh_base.sandesh_global):
    sandesh_base.SandeshRequest.__init__(self)
    self.type_info = type_info
    self.success = success
    self._scope = sandesh.scope()
    self._module = sandesh.module()
    self._source = sandesh.source_id()
    self._node_type = sandesh.node_type()
    self._instance_id = sandesh.instance_id()
    self._seqnum = 0
    self._timestamp = UTCTimestampUsec()
    self._versionsig = 1746741351
    self._hints = 0

  @staticmethod
  def handle_http_request(sandesh=sandesh_base.sandesh_global):
    sandesh_req = SandeshCtrlServerToClient()
    if not sandesh_req:
      return SandeshHttp.http_error('Sandesh Request "SandeshCtrlServerToClient" not implemented')
    if bottle.request.query.success:
      try:
        sandesh_req.success = int(bottle.request.query.success)
      except ValueError:
        return SandeshHttp.http_error('Invalid data provided in Sandesh Request')
    sandesh_req._context = bottle.request.url
    handle_req_fn = getattr(sandesh_req, "handle_request", None)
    if callable(handle_req_fn):
      handle_req_fn(sandesh_req)
    else:
      return SandeshHttp.http_error('Sandesh Request "SandeshCtrlServerToClient" not implemented')
    resp = SandeshHttp.get_http_response()
    if resp:
      return resp
    else:
      return SandeshHttp.http_error('No Response for Sandesh Request "SandeshCtrlServerToClient"')
    
  def log(self, trace=False):
    log_str = cStringIO.StringIO()
    if trace:
      log_str.write(str(self._timestamp))
      log_str.write(' ')
    log_str.write(self.__class__.__name__ + ': ')
    if self.type_info is not None:
      log_str.write('type_info = ')
      log_str.write('[ ')
      for iter8 in self.type_info:
        log_str.write('<<  ')
        log_str.write(iter8.log())
        log_str.write('>>')
        log_str.write(', ')
      log_str.write(' ]')
      log_str.write('  ')
    if self.success is not None:
      log_str.write('success = ')
      if self.success:
        log_str.write('True')
      else:
        log_str.write('False')
      log_str.write('  ')
    return log_str.getvalue()

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return -1
    read_cnt = 0
    (length, sandesh_name) = iprot.readSandeshBegin()
    if length < 0: return -1
    read_cnt += length
    while True:
      (length, fname, ftype, fid) = iprot.readFieldBegin()
      if length < 0: return -1
      read_cnt += length
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.type_info = []
          (length, _etype12, _size9) = iprot.readListBegin()
          read_cnt += length
          for _i13 in xrange(_size9):
            _elem14 = UVETypeInfo()
            read_cnt += _elem14.read(iprot)
            self.type_info.append(_elem14)
          read_cnt += iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          (length, self.success) = iprot.readBool();
          if length < 0: return -1
          read_cnt += length
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      length = iprot.readFieldEnd()
      if length < 0: return -1
      read_cnt += length
    length = iprot.readSandeshEnd()
    if length < 0: return -1
    read_cnt += length
    return read_cnt

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return 0
    if oprot.writeSandeshBegin(self.__class__.__name__) < 0: return -1
    if self.type_info is not None:
      annotations = {}
      if oprot.writeFieldBegin('type_info', TType.LIST, 1, annotations) < 0: return -1
      if oprot.writeListBegin(TType.STRUCT, len(self.type_info)) < 0: return -1
      for iter15 in self.type_info:
        if iter15.write(oprot) < 0: return -1
      if oprot.writeListEnd() < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if self.success is not None:
      annotations = {}
      if oprot.writeFieldBegin('success', TType.BOOL, 2, annotations) < 0: return -1
      if oprot.writeBool(self.success) < 0: return -1
      if oprot.writeFieldEnd() < 0: return -1
    if oprot.writeFieldStop() < 0: return -1
    if oprot.writeSandeshEnd() < 0: return -1
    return 0

  def validate(self):
    return


  def compare(self, other):
    if not isinstance(other, self.__class__):
      return False
    if self.type_info != other.type_info:
      return False
    if self.success != other.success:
      return False
    return True

  def __sizeof__(self):
    size = 0
    if self.type_info is not None:
      size += getsizeof(self.type_info)
      size += sum(map(getsizeof, self.type_info))
    if self.success is not None:
      size += getsizeof(self.success)
    return size

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


_SANDESH_REQUEST_LIST = [
SandeshCtrlClientToServer,
SandeshCtrlServerToClient,
]


_SANDESH_UVE_LIST = [
]


_SANDESH_ALARM_LIST = [
]
